diff --git a/Functions/util.udfTrimLeadingZeros.sql b/Functions/util.udfTrimLeadingZeros.sql
new file mode 100644
index 0000000..8846d1c
--- /dev/null
+++ b/Functions/util.udfTrimLeadingZeros.sql
@@ -0,0 +1,19 @@
+SET QUOTED_IDENTIFIER ON
+GO
+SET ANSI_NULLS ON
+GO
+/*
+	Author:			Jordan Gurney
+	Create Date:	7/12/2017
+	Description:	Trims leading zeros from a string (needed for ETL)
+	Sample Execute:
+					SELECT util.udfTrimLeadingZeros('010084700')
+*/
+CREATE FUNCTION [util].[udfTrimLeadingZeros](@Input VARCHAR(4000))
+RETURNS VARCHAR(4000)
+AS BEGIN RETURN
+(
+	SELECT SUBSTRING(@Input, PATINDEX('%[^0]%', @Input + '.'), LEN(@Input))
+)
+END
+GO
diff --git a/RedGateDatabaseInfo.xml b/RedGateDatabaseInfo.xml
new file mode 100644
index 0000000..0bcb4d9
--- /dev/null
+++ b/RedGateDatabaseInfo.xml
@@ -0,0 +1,78 @@
+ï»¿<?xml version="1.0" encoding="utf-8"?>
+<DatabaseInformation Version="2">
+  <ScriptFileEncoding>UTF8</ScriptFileEncoding>
+  <DefaultCollation>SQL_Latin1_General_CP1_CI_AS</DefaultCollation>
+  <DefaultSchema>dbo</DefaultSchema>
+  <DefaultUser>dbo</DefaultUser>
+  <DefaultFilegroup>PRIMARY</DefaultFilegroup>
+  <DatabaseVersion>13</DatabaseVersion>
+  <IsAzure>False</IsAzure>
+  <MaxDataFileSize>10485760</MaxDataFileSize>
+  <WriteToFileOptions>
+    <Prefixes>
+      <None>
+      </None>
+      <Table>Tables</Table>
+      <StoredProcedure>Stored Procedures</StoredProcedure>
+      <View>Views</View>
+      <Default>Defaults</Default>
+      <FullTextCatalog>Storage\Full Text Catalogs</FullTextCatalog>
+      <Function>Functions</Function>
+      <Role>Security\Roles</Role>
+      <Rule>Rules</Rule>
+      <User>Security\Users</User>
+      <UserDefinedType>Types\User-defined Data Types</UserDefinedType>
+      <Trigger>
+      </Trigger>
+      <DdlTrigger>Database Triggers</DdlTrigger>
+      <Assembly>Assemblies</Assembly>
+      <Synonym>Synonyms</Synonym>
+      <XmlSchemaCollection>Types\XML Schema Collections</XmlSchemaCollection>
+      <MessageType>Service Broker\Message Types</MessageType>
+      <Contract>Service Broker\Contracts</Contract>
+      <Queue>Service Broker\Queues</Queue>
+      <Service>Service Broker\Services</Service>
+      <Route>Service Broker\Routes</Route>
+      <EventNotification>Service Broker\Event Notifications</EventNotification>
+      <PartitionScheme>Storage\Partition Schemes</PartitionScheme>
+      <PartitionFunction>Storage\Partition Functions</PartitionFunction>
+      <Field>
+      </Field>
+      <Index>
+      </Index>
+      <Schema>Security\Schemas</Schema>
+      <ServiceBinding>Service Broker\Remote Service Bindings</ServiceBinding>
+      <Certificate>Security\Certificates</Certificate>
+      <SymmetricKey>Security\Symmetric Keys</SymmetricKey>
+      <AsymmetricKey>Security\Asymmetric Keys</AsymmetricKey>
+      <CheckConstraint>
+      </CheckConstraint>
+      <FullTextStoplist>Storage\Full Text Stoplists</FullTextStoplist>
+      <ExtendedProperty>Extended Properties</ExtendedProperty>
+      <Data>Data</Data>
+      <Sequence>Sequences</Sequence>
+      <SearchPropertyList>Search Property Lists</SearchPropertyList>
+      <SecurityPolicy>Security Policies</SecurityPolicy>
+    </Prefixes>
+    <DataWriteAllFilesInOneDirectory>True</DataWriteAllFilesInOneDirectory>
+  </WriteToFileOptions>
+  <DataFileSet>
+    <Count>16</Count>
+    <DataFile>dbo.AspNetRoles_Data.sql</DataFile>
+    <DataFile>dbo.Gender_Data.sql</DataFile>
+    <DataFile>dbo.UsState_Data.sql</DataFile>
+    <DataFile>dbo.ClaimImageType_Data.sql</DataFile>
+    <DataFile>dbo.ClaimNoteType_Data.sql</DataFile>
+    <DataFile>dbo.EpisodeLinkType_Data.sql</DataFile>
+    <DataFile>dbo.PrescriptionNoteType_Data.sql</DataFile>
+    <DataFile>dbo.AspNetUserRoles_Data.sql</DataFile>
+    <DataFile>dtme.Calendar_Data.sql</DataFile>
+    <DataFile>dtme.TimeZoneInfo_Data.sql</DataFile>
+    <DataFile>dbo.DiaryType_Data.sql</DataFile>
+    <DataFile>util.ExcelColumn_Data.sql</DataFile>
+    <DataFile>dbo.EpisodeType_Data.sql</DataFile>
+    <DataFile>util.ImportFileType_Data.sql</DataFile>
+    <DataFile>dtme.TimeZone_Data.sql</DataFile>
+    <DataFile>etl.LatestStagedLakerFileLoaded_Data.sql</DataFile>
+  </DataFileSet>
+</DatabaseInformation>
\ No newline at end of file
diff --git a/Security/Schemas/etl.sql b/Security/Schemas/etl.sql
new file mode 100644
index 0000000..05e59b0
--- /dev/null
+++ b/Security/Schemas/etl.sql
@@ -0,0 +1,3 @@
+CREATE SCHEMA [etl]
+AUTHORIZATION [dbo]
+GO
diff --git a/Security/Schemas/util.sql b/Security/Schemas/util.sql
new file mode 100644
index 0000000..23024e3
--- /dev/null
+++ b/Security/Schemas/util.sql
@@ -0,0 +1,3 @@
+CREATE SCHEMA [util]
+AUTHORIZATION [dbo]
+GO
diff --git a/Stored Procedures/dbo.uspCreateIndexedPrescriptionNoteView.sql b/Stored Procedures/dbo.uspCreateIndexedPrescriptionNoteView.sql
new file mode 100644
index 0000000..08d0a70
--- /dev/null
+++ b/Stored Procedures/dbo.uspCreateIndexedPrescriptionNoteView.sql
@@ -0,0 +1,72 @@
+SET QUOTED_IDENTIFIER ON
+GO
+SET ANSI_NULLS ON
+GO
+/*
+	Author:			Jordan Gurney
+	Create Date:	7/11/2017
+	Description:	Creates the Prescription Note View Definition. This is needed for 
+					routine schema changes that are blocked by the SCHEMABINDING of this VIEW.
+	Sample Execute:
+					EXEC dbo.uspCreateIndexedPrescriptionNoteView
+*/
+CREATE PROC [dbo].[uspCreateIndexedPrescriptionNoteView]
+AS BEGIN
+	SET NOCOUNT ON;
+	SET ARITHABORT ON;
+	SET CONCAT_NULL_YIELDS_NULL ON;
+	SET QUOTED_IDENTIFIER ON;
+	SET ANSI_NULLS ON;
+	SET ANSI_PADDING ON;
+	SET ANSI_WARNINGS ON;
+	SET NUMERIC_ROUNDABORT OFF;
+	DECLARE @SQLStatement NVARCHAR(4000)
+	IF EXISTS (SELECT * FROM sys.[views] AS [v] WHERE [v].[name] = 'vwPrescriptionNote')
+		BEGIN
+			RAISERROR(N'The Prescription Note View already exists. Execute the statement: DROP VIEW dbo.vwPrescriptionNote', 10, 1) WITH NOWAIT
+			RETURN
+		END
+	RAISERROR(N'Creating Prescription Note View...', 10, 1) WITH NOWAIT
+	SELECT @SQLStatement = N'CREATE VIEW [dbo].[vwPrescriptionNote]
+	WITH SCHEMABINDING
+	AS	
+		SELECT [p].[ClaimID], [p].[PrescriptionID], p.[RxNumber], p.[DateFilled], p.[LabelName],
+			[pn].[PrescriptionNoteID], [pnt].[TypeName] PrescriptionNoteType, [pn].[NoteText], 
+			[u].[FirstName] + '' ''+ [u].[LastName] NoteAuthor,
+			[pn].[CreatedOnUTC] NoteCreatedOn, [pn].[UpdatedOnUTC] NoteUpdatedOn
+		FROM [dbo].[Prescription] AS [p]
+			INNER JOIN [dbo].[PrescriptionNoteMapping] AS [pnm] ON [pnm].[PrescriptionID] = [p].[PrescriptionID]
+			INNER JOIN [dbo].[PrescriptionNote] AS [pn] INNER JOIN [dbo].[PrescriptionNoteType] AS [pnt] ON [pnt].[PrescriptionNoteTypeID] = [pn].[PrescriptionNoteTypeID]
+				ON [pn].[PrescriptionNoteID] = [pnm].[PrescriptionNoteID]
+			INNER JOIN [dbo].[AspNetUsers] AS [u] ON [u].[ID] = [pn].[EnteredByUserID]';
+	-- Create View
+	EXEC sys.sp_executesql @SQLStatement;
+
+	SET @SQLStatement = N'CREATE UNIQUE CLUSTERED INDEX [idxUqClusVwPrescriptionNote] ON [dbo].[vwPrescriptionNote]
+					(
+						[PrescriptionID] ASC,
+						[PrescriptionNoteID] ASC
+					)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF,
+					 ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90, DATA_COMPRESSION = ROW)';
+	EXEC sys.sp_executesql @SQLStatement;
+
+	SET @SQLStatement =
+	N'CREATE NONCLUSTERED INDEX [idxVwPrescriptionNoteClaimIDPrescriptionIDIncludeAll] ON [dbo].[vwPrescriptionNote]
+	(
+		[ClaimID] ASC,
+		[PrescriptionID] ASC
+	)
+	INCLUDE ( 	[RxNumber],
+		[DateFilled],
+		[LabelName],
+		[PrescriptionNoteID],
+		[PrescriptionNoteType],
+		[NoteText],
+		[NoteAuthor],
+		[NoteCreatedOn],
+		[NoteUpdatedOn]) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF,
+		 ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90, DATA_COMPRESSION = PAGE)';
+	EXEC sys.sp_executesql @SQLStatement;
+END
+
+GO
diff --git a/Stored Procedures/dbo.uspGetClaimsSearchResults.sql b/Stored Procedures/dbo.uspGetClaimsSearchResults.sql
new file mode 100644
index 0000000..f0da4fa
--- /dev/null
+++ b/Stored Procedures/dbo.uspGetClaimsSearchResults.sql
@@ -0,0 +1,64 @@
+SET QUOTED_IDENTIFIER ON
+GO
+SET ANSI_NULLS ON
+GO
+/*
+	Author:			Jordan Gurney
+	Create Date:	6/10/2017
+	Description:	Returns Claims data for Blade 1
+	Sample Execute:
+					EXEC dbo.uspGetClaimsSearchResults @FirstName = 'amie'
+*/
+CREATE PROC [dbo].[uspGetClaimsSearchResults]
+(
+    @ClaimNumber VARCHAR(255) = NULL, @FirstName VARCHAR(155) = NULL, 
+    @LastName VARCHAR(155) = NULL, @RxNumber VARCHAR(100) = NULL, @InvoiceNumber NVARCHAR(100) = NULL
+)
+AS
+BEGIN
+    SET NOCOUNT ON;
+
+	WITH ClaimsCTE AS
+	(
+			SELECT c.ClaimID
+			FROM   dbo.Claim AS c
+			WHERE  c.ClaimNumber LIKE '%' + @ClaimNumber + '%'
+		  
+			UNION
+
+			SELECT c.ClaimID
+			FROM   dbo.Claim AS c
+				   INNER JOIN dbo.Patient AS p ON c.PatientID = p.PatientID
+			WHERE  p.FirstName LIKE '%' + @FirstName + '%'
+				   OR p.LastName LIKE '%' + @LastName + '%'
+			
+			UNION
+
+			SELECT p.ClaimID
+			FROM   dbo.Invoice AS i
+					INNER JOIN dbo.Prescription AS p ON p.InvoiceID = i.InvoiceID
+			WHERE  i.InvoiceNumber = @InvoiceNumber
+
+			UNION
+
+			SELECT p.ClaimID
+			FROM   dbo.Prescription AS p
+			WHERE  p.RxNumber = @RxNumber
+    )
+    SELECT DISTINCT c.ClaimId
+		 , c.PayorId
+         , c.ClaimNumber
+         , c.LastName
+         , c.FirstName
+         , c.Carrier
+         , c.InjuryDate
+    FROM   [dbo].[vwClaim] c 
+           INNER JOIN ClaimsCTE cte ON cte.ClaimID = c.ClaimId
+    WHERE  1 = 1
+           AND (c.ClaimNumber LIKE '%' + @ClaimNumber + '%' OR @ClaimNumber IS NULL)
+           AND (c.FirstName LIKE '%' + @FirstName + '%' OR @FirstName IS NULL)
+           AND (c.LastName LIKE '%' + @LastName + '%' OR @LastName IS NULL)
+           AND (c.InvoiceNumber = @InvoiceNumber OR @InvoiceNumber IS NULL)
+           AND (c.RxNumber = @RxNumber OR @RxNumber IS NULL);
+END
+GO
diff --git a/Stored Procedures/etl.uspAddStagedLakerFileETLColumns.sql b/Stored Procedures/etl.uspAddStagedLakerFileETLColumns.sql
new file mode 100644
index 0000000..af9b1b6
--- /dev/null
+++ b/Stored Procedures/etl.uspAddStagedLakerFileETLColumns.sql
@@ -0,0 +1,173 @@
+SET QUOTED_IDENTIFIER ON
+GO
+SET ANSI_NULLS ON
+GO
+/*
+	Author:			Jordan Gurney
+	Create Date:	7/11/2017
+	Description:	Adds the necessary columns for ETL.
+	Sample Execute:
+					EXEC [etl].[uspAddStagedLakerFileETLColumns]
+*/
+CREATE PROC [etl].[uspAddStagedLakerFileETLColumns]
+AS BEGIN
+	SET NOCOUNT ON;
+	SET TRAN ISOLATION LEVEL SERIALIZABLE;
+	SET DEADLOCK_PRIORITY HIGH;
+	BEGIN TRY;
+		BEGIN TRANSACTION;
+		/****************************************************************************
+		First, we're going to add all of the columns from the import tables to the staging table.
+		****************************************************************************/
+		DECLARE @Obj INTEGER = OBJECT_ID(N'etl.StagedLakerFile', N'U')
+		IF NOT EXISTS
+		(
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'PayorID'
+				  AND [t].[object_id] = @Obj
+		)
+			ALTER TABLE [etl].[StagedLakerFile] ADD [PayorID] INTEGER NULL
+		IF NOT EXISTS
+		(
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'AcctPayableID'
+				  AND [t].[object_id] = @Obj
+		)
+			ALTER TABLE [etl].[StagedLakerFile] ADD [AcctPayableID] INTEGER NULL
+		IF NOT EXISTS
+	    (
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'AdjustorID'
+				  AND [t].[object_id] = @Obj
+		)
+			ALTER TABLE [etl].[StagedLakerFile] ADD [AdjustorID] INTEGER NULL
+		IF NOT EXISTS
+	    (
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'PatientID'
+				  AND [t].[object_id] = @Obj
+		)
+			ALTER TABLE [etl].[StagedLakerFile] ADD [PatientID] INTEGER NULL
+		IF NOT EXISTS
+	    (
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'InvoiceID'
+				  AND [t].[object_id] = @Obj
+		)
+			ALTER TABLE [etl].[StagedLakerFile] ADD [InvoiceID] INTEGER NULL
+		IF NOT EXISTS
+	    (
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'ClaimID'
+				  AND [t].[object_id] = @Obj
+		)
+			ALTER TABLE [etl].[StagedLakerFile] ADD [ClaimID] INTEGER NULL
+		IF NOT EXISTS
+	    (
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'PrescriptionID'
+				  AND [t].[object_id] = @Obj
+		)
+			ALTER TABLE [etl].[StagedLakerFile] ADD [PrescriptionID] INTEGER NULL
+		IF NOT EXISTS
+	    (
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'PharmacyID'
+				  AND [t].[object_id] = @Obj
+		)
+			ALTER TABLE [etl].[StagedLakerFile] ADD [PharmacyID] INTEGER NULL
+		/****************************************************************************
+		Now, we're going to move on to the import tables themselves, and permanently add Columns for the Import
+		****************************************************************************/
+		-- Payor
+		IF NOT EXISTS
+        (
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'ETLRowID'
+				  AND [t].[object_id] = OBJECT_ID(N'dbo.Payor', N'U')
+		)
+			ALTER TABLE dbo.[Payor] ADD ETLRowID VARCHAR(50) NULL
+		-- Adjustor
+		IF NOT EXISTS
+        (
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'ETLRowID'
+				  AND [t].[object_id] = OBJECT_ID(N'dbo.Adjustor', N'U')
+		)
+			ALTER TABLE dbo.[Adjustor] ADD ETLRowID VARCHAR(50) NULL
+		-- Patient
+		IF NOT EXISTS
+        (
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'ETLRowID'
+				  AND [t].[object_id] = OBJECT_ID(N'dbo.Patient', N'U')
+		)
+			ALTER TABLE dbo.[Patient] ADD ETLRowID VARCHAR(50) NULL
+		-- Claim
+		IF NOT EXISTS
+        (
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'ETLRowID'
+				  AND [t].[object_id] = OBJECT_ID(N'dbo.Claim', N'U')
+		)
+			ALTER TABLE dbo.[Claim] ADD ETLRowID VARCHAR(50) NULL
+		-- Invoice
+		IF NOT EXISTS
+        (
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'ETLRowID'
+				  AND [t].[object_id] = OBJECT_ID(N'dbo.Invoice', N'U')
+		)
+			ALTER TABLE dbo.[Invoice] ADD ETLRowID VARCHAR(50) NULL
+		-- Pharmacy
+		IF NOT EXISTS
+        (
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'ETLRowID'
+				  AND [t].[object_id] = OBJECT_ID(N'dbo.Pharmacy', N'U')
+		)
+			ALTER TABLE dbo.[Pharmacy] ADD ETLRowID VARCHAR(50) NULL
+		-- Prescription
+		IF NOT EXISTS
+        (
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'ETLRowID'
+				  AND [t].[object_id] = OBJECT_ID(N'dbo.Prescription', N'U')
+		)
+			ALTER TABLE dbo.[Prescription] ADD ETLRowID VARCHAR(50) NULL
+		-- Payment
+		IF NOT EXISTS
+        (
+			SELECT * FROM [sys].[columns] AS [c]
+			INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+			WHERE [c].[name] = 'ETLRowID'
+				  AND [t].[object_id] = OBJECT_ID(N'dbo.AcctPayable', N'U')
+		)
+			ALTER TABLE dbo.[AcctPayable] ADD ETLRowID VARCHAR(50) NULL
+		IF (@@TRANCOUNT > 0)
+			COMMIT TRANSACTION;
+	END TRY
+	BEGIN CATCH
+		IF (@@TRANCOUNT > 0)
+			ROLLBACK TRANSACTION;
+		THROW;
+	END CATCH
+END
+
+
+GO
diff --git a/Stored Procedures/etl.uspProcessLakerFile.sql b/Stored Procedures/etl.uspProcessLakerFile.sql
new file mode 100644
index 0000000..4b53b40
--- /dev/null
+++ b/Stored Procedures/etl.uspProcessLakerFile.sql
@@ -0,0 +1,677 @@
+SET QUOTED_IDENTIFIER ON
+GO
+SET ANSI_NULLS ON
+GO
+/*
+	Author:			Jordan Gurney
+	Create Date:	7/24/2017
+	Description:	Main ETL Proc
+	Sample Execute:
+					EXEC etl.uspProcessLakerFile
+*/
+CREATE PROC [etl].[uspProcessLakerFile]
+WITH RECOMPILE -- Not for performance, but out of
+			   -- necessity for compilation and avoiding parser errors.
+AS BEGIN
+	SET NOCOUNT ON;
+	SET TRAN ISOLATION LEVEL SERIALIZABLE;
+	SET DEADLOCK_PRIORITY HIGH;
+	-- Testing
+	-- Preparatory work
+	-- Rename row 1 to RowID
+	/*EXEC(N'EXEC sys.sp_rename ''[etl].[StagedLakerFile].[1]'',''RowID'',''column''')
+	-- Reduce Character limit on our RowID from 8000 to 50
+	EXEC(N'ALTER TABLE [etl].[StagedLakerFile] ALTER COLUMN RowID VARCHAR(50) NOT NULL')
+	-- Add Primary Key to our Unique Row ID for our Staging Table
+	EXEC(N'ALTER TABLE [etl].[StagedLakerFile] WITH CHECK ADD CONSTRAINT pkStagedLakerFile
+	PRIMARY KEY CLUSTERED ([RowID] ASC) WITH (FILLFACTOR=100,DATA_COMPRESSION=ROW)')*/
+	-- Import tables should already be prepared, but if not, let's run Proc
+	EXEC [etl].[uspAddStagedLakerFileETLColumns]
+	IF EXISTS
+	(
+		SELECT * FROM [sys].[columns] AS [c]
+		INNER JOIN [sys].[tables] AS [t] ON [t].[object_id] = [c].[object_id]
+		INNER JOIN [sys].[schemas] AS [s] ON [s].[schema_id] = [t].[schema_id]
+		WHERE [s].[name] = 'etl'
+		AND [t].[name] = 'StagedLakerFile'
+		AND [c].[name] = 'StageID'
+	)
+		EXEC(N'ALTER TABLE [etl].[StagedLakerFile] DROP COLUMN StageID')
+
+	IF OBJECT_ID(N'tempdb..#Payor') IS NOT NULL
+			DROP TABLE #Payor
+	IF OBJECT_ID(N'tempdb..#Adjustor') IS NOT NULL
+			DROP TABLE #Adjustor
+	IF OBJECT_ID(N'tempdb..#PatientImport') IS NOT NULL
+			DROP TABLE #PatientImport
+	IF OBJECT_ID(N'tempdb..#ProcessPatient') IS NOT NULL
+			DROP TABLE #ProcessPatient
+	IF OBJECT_ID(N'tempdb..#ProcessPharmacy') IS NOT NULL
+			DROP TABLE #ProcessPharmacy
+	IF OBJECT_ID(N'tempdb..#ProcessClaim') IS NOT NULL
+			DROP TABLE #ProcessClaim
+	IF OBJECT_ID(N'tempdb..#ClaimImport') IS NOT NULL
+			DROP TABLE #ClaimImport
+	IF OBJECT_ID(N'tempdb..#InvoiceImport') IS NOT NULL
+			DROP TABLE #InvoiceImport
+	IF OBJECT_ID(N'tempdb..#ProcessInvoice') IS NOT NULL
+			DROP TABLE #ProcessInvoice
+	IF OBJECT_ID(N'tempdb..#PharmacyImport') IS NOT NULL
+			DROP TABLE #PharmacyImport
+	IF OBJECT_ID(N'tempdb..#UpdatePatient') IS NOT NULL
+			DROP TABLE #UpdatePatient
+	IF OBJECT_ID(N'tempdb..#UpdateClaim') IS NOT NULL
+			DROP TABLE #UpdateClaim
+	IF OBJECT_ID(N'tempdb..#TransientPatient') IS NOT NULL
+			DROP TABLE #TransientPatient
+	IF OBJECT_ID(N'tempdb..#UpdateInvoice') IS NOT NULL
+			DROP TABLE #UpdateInvoice
+
+	DECLARE @TotalRowCount INT = (SELECT COUNT(*) FROM [etl].[StagedLakerFile])
+	-- Clear out tables that we're going to be loading
+	IF EXISTS (SELECT * FROM [sys].[views] AS [v] WHERE [v].[name] = 'vwPrescriptionNote')
+		DROP VIEW [dbo].[vwPrescriptionNote]
+	EXEC [util].[uspSmarterTruncateTable] 'dbo.ClaimNote'
+	EXEC [util].[uspSmarterTruncateTable] 'dbo.PrescriptionNoteMapping'
+	EXEC [util].[uspSmarterTruncateTable] 'dbo.PrescriptionNote'
+	EXEC [util].[uspSmarterTruncateTable] 'dbo.Prescription'
+	EXEC [util].[uspSmarterTruncateTable] 'dbo.AcctPayable'
+	EXEC [util].[uspSmarterTruncateTable] 'dbo.Invoice'
+	EXEC [util].[uspSmarterTruncateTable] 'dbo.Pharmacy'
+	EXEC [util].[uspSmarterTruncateTable] 'dbo.Episode'
+	EXEC [util].[uspSmarterTruncateTable] 'dbo.ClaimsUserHistory'
+	EXEC [util].[uspSmarterTruncateTable] 'dbo.Claim'
+	EXEC [util].[uspSmarterTruncateTable] 'dbo.Patient'
+	EXEC [util].[uspSmarterTruncateTable] 'dbo.Adjustor'
+	EXEC [util].[uspSmarterTruncateTable] 'dbo.Payor'
+				
+	DECLARE @RowCountCheck INT
+	IF NOT EXISTS
+	(
+		SELECT	* 
+		FROM	[etl].[StagedLakerFile]
+	)
+	BEGIN
+		IF @@TRANCOUNT > 0
+			ROLLBACK;
+		RAISERROR(N'Nothing to Process. The etl.StagedLakerFile table is empty', 1, 1) WITH NOWAIT;
+		RETURN;
+	END
+	/********************************************************************************************
+	Import Payor Section
+	********************************************************************************************/
+	CREATE TABLE #Payor ([42] [varchar](8000) NULL,[43] [varchar](8000) NULL,[44] [varchar](8000) NULL,[45] 
+		[varchar](8000) NULL,[46] [varchar](8000) NULL,[StateID] [int] NULL,[48] [varchar](8000) NULL,[49] [varchar](8000) NULL,[50]
+		[varchar](8000) NULL, RowNumber INT NOT NULL, DenseRank INT NOT NULL, ETLRowID VARCHAR(50) NOT NULL)
+	INSERT [#Payor] ([42],[43],[44],[45],[46],[StateID],[48],[49],[50],[RowNumber],[DenseRank],[ETLRowID])
+	SELECT [s].[42], [s].[43],[s].[44],[s].[45],[s].[46],[us].[StateID],s.[48],s.[49],s.[50]
+			,ROW_NUMBER() OVER (PARTITION BY [s].[42], [s].[43],[s].[44],[s].[45],[s].[46],[us].[StateID],s.[48],s.[49],s.[50] ORDER BY [s].[42] ASC) RowNumber
+			,DENSE_RANK() OVER (ORDER BY [s].[42], [s].[43],[s].[44],[s].[45],[s].[46],[us].[StateID],s.[48],s.[49],s.[50] ASC) DenseRank, [s].[RowID]
+	FROM   [etl].[StagedLakerFile] AS s
+			LEFT JOIN [dbo].[UsState] AS [us] ON [us].[StateCode] = [s].[47]
+	WHERE  [s].[47] IS NOT NULL
+	
+	-- Actual Payor Import
+	INSERT [dbo].[Payor] ([GroupName],[BillToName],[BillToAddress1],[BillToAddress2],[BillToCity],[BillToStateID],[BillToPostalCode],[PhoneNumber],[FaxNumber],[ETLRowID])
+	SELECT [42],[43],[44],[45],[46],[StateID],[48],[49],[50],[ETLRowID] 
+	FROM [#Payor] AS [p]
+	WHERE [RowNumber] = 1
+	ORDER BY [42] ASC
+	SET @RowCountCheck = @@ROWCOUNT;
+			
+	IF (SELECT COUNT(*) FROM [dbo].[Payor] AS [p]) != @RowCountCheck
+		BEGIN
+			IF @@TRANCOUNT > 0
+				ROLLBACK
+			RAISERROR(N'The Payor count QA check failed', 16, 1) WITH NOWAIT
+			RETURN
+		END
+
+	UPDATE s
+	SET    [s].[PayorID] = [pi].[PayorID]
+	FROM   [etl].[StagedLakerFile] AS s WITH (TABLOCKX)
+			INNER JOIN dbo.Payor AS [pi] ON [s].[42] = [pi].[GroupName]; -- This one's easier than most beacause Group Name is Unique
+			
+	-- Another Payor QA Check
+	IF @RowCountCheck != (SELECT COUNT(DISTINCT [PayorID]) FROM etl.[StagedLakerFile])
+		BEGIN
+			IF @@TRANCOUNT > 0
+				ROLLBACK;
+			RAISERROR(N'Error. The row count for the Payor Insert does not match the corresponding Row Count for distinct PayorID''s in the Staging table', 16, 1) WITH NOWAIT;
+			RETURN;
+		END
+
+	-- Another Payor QA check. This ensures that there is a Payor record on every line.
+	EXEC [sys].[sp_executesql] N'ALTER TABLE [etl].[StagedLakerFile] ALTER COLUMN PayorID INT NOT NULL';
+	-- Ok, if that worked, change it back.
+	EXEC [sys].[sp_executesql] N'ALTER TABLE [etl].[StagedLakerFile] ALTER COLUMN PayorID INT NULL';
+	/********************************************************************************************
+	End Payor Section
+	********************************************************************************************/
+
+	/********************************************************************************************
+	Import Adjustor Section 
+	Notes: It is impossible to distinctly identify an Adjustor unless they all have distinct AdjustorName's.
+			In this data set, I found 432 unique, Adjustor names, but when I imported all of them, with their corresponding
+			PayorID's, this results in a total of 457 rows being imported. Because I found multiple Payor ID's for a single
+			Adjustor name more than once.
+	Query to identify problem:
+			WITH AdjustorCTE
+			AS ( SELECT   [s].[PayorID]
+						, [s].[21]
+						, RowID = ROW_NUMBER() OVER ( PARTITION BY [s].[21]
+														ORDER BY [s].[21]
+																, [s].[PayorID]
+													)
+					FROM     [etl].[StagedLakerFile] AS s
+					WHERE    [s].[21] IS NOT NULL
+					GROUP BY [s].[PayorID]
+						, [s].[21]
+				)
+			SELECT [a].[21], MAX(a.[RowID]) TotalPayorIDs
+			FROM   [AdjustorCTE] AS a
+			WHERE  [a].[RowID] > 1
+			GROUP BY [a].[21]
+
+			RETURN
+
+			SELECT Payor = [p].[GroupName]
+					, a.*
+			FROM   [dbo].[Adjustor] AS [a]
+					INNER JOIN [dbo].[Payor] AS [p] ON [p].[PayorID] = [a].[PayorID]
+			WHERE  [a].[AdjustorName] = 'NATASHA IRIZARRY'
+	********************************************************************************************/
+	CREATE TABLE #Adjustor (PayorID INT NOT NULL, AdjustorName VARCHAR(255) NOT NULL, RowNumber INT NOT NULL, 
+							DenseRank INT NOT NULL, ETLRowID VARCHAR(50) NOT NULL)
+	INSERT [#Adjustor] ([PayorID],[AdjustorName],[RowNumber],[DenseRank],[ETLRowID])
+	SELECT s.[PayorID],s.[21],ROW_NUMBER() OVER (PARTITION BY s.[PayorID], s.[21] ORDER BY s.[21] ASC) RowNumber,
+	DENSE_RANK() OVER (ORDER BY s.[PayorID], s.[21] ASC) DenseRank, [s].[RowID]
+	FROM etl.[StagedLakerFile] AS s 
+	WHERE s.[21] IS NOT NULL 
+	ORDER BY s.[21]
+			
+	-- Actual Adjustor Import
+	INSERT [dbo].[Adjustor] ([PayorID], [AdjustorName], [ETLRowID])
+	SELECT a.[PayorID], a.[AdjustorName], [a].[ETLRowID] FROM [#Adjustor] AS [a]
+	WHERE [a].[RowNumber] = 1
+	SET @RowCountCheck = @@ROWCOUNT;
+				
+	UPDATE s SET s.AdjustorID = a.[AdjustorID]
+	FROM   [etl].[StagedLakerFile] AS s WITH (TABLOCKX)
+			INNER JOIN dbo.Adjustor AS a ON a.AdjustorName = s.[21]
+	WHERE  a.PayorID = s.PayorID;
+			
+	-- Adjustor QA Check
+	IF @RowCountCheck != (SELECT COUNT(DISTINCT [s].[AdjustorID]) FROM etl.[StagedLakerFile] AS s)
+		BEGIN
+			IF @@TRANCOUNT > 0
+				ROLLBACK;
+			RAISERROR(N'Error. The row count for the Payor Insert does not match the corresponding Row Count for distinct PayorID''s in the Staging table', 16, 1) WITH NOWAIT;
+			RETURN;
+		END
+			
+	/********************************************************************************************
+	End Adjustor Section
+	********************************************************************************************/
+
+	/********************************************************************************************
+	Begin Patient Section
+	********************************************************************************************/
+	CREATE TABLE #PatientImport
+	(
+		[DateOfBirth] [varchar] (8000) NULL,
+		[LastName] [varchar] (8000) NULL,
+		[FirstName] [varchar] (8000) NULL,
+		[Address1] [varchar] (8000) NULL,
+		[Address2] [varchar] (8000) NULL,
+		[City] [varchar] (8000) NULL,
+		[StateID] [int] NULL,
+		[PostalCode] [varchar] (8000) NULL,
+		[PhoneNumber] [varchar] (8000) NULL,
+		[GenderID] [int] NULL,
+		[RowNumber] INT NOT NULL,
+		DenseRank INT NOT NULL,
+		[ETLRowID] VARCHAR(50) NOT NULL
+	)
+	INSERT [#PatientImport] ([DateOfBirth],[LastName], [FirstName], [Address1], [Address2], [City], [StateID],[PostalCode]
+									, [PhoneNumber],[GenderID], [RowNumber], [DenseRank], [ETLRowID])
+	SELECT p.[20], p.[10], p.[11], p.[12],p.[13],p.[14], [us].[StateID],p.[16],p.[17],g.[GenderID]
+	,ROW_NUMBER() OVER (PARTITION BY p.[20], p.[10], p.[11], p.[12],p.[13],p.[14], p.[15],p.[16],p.[17],P.[18] ORDER BY p.[20]) RowID
+	,DENSE_RANK() OVER (ORDER BY p.[20], p.[10], p.[11], p.[12],p.[13],p.[14], [us].[StateID],p.[16],p.[17],g.[GenderID]) DenseRank, p.[RowID]
+	FROM [etl].[StagedLakerFile] AS p
+	LEFT JOIN [dbo].[UsState] AS [us] ON p.[15] = [us].[StateCode]
+	LEFT JOIN [dbo].[Gender] AS [g] ON g.[GenderCode] = p.[18]
+	WHERE p.[10] IS NOT NULL
+
+	-- Patient import statement
+	INSERT [dbo].[Patient] ([DateOfBirth],[LastName],[FirstName], [Address1],[Address2],[City],[StateID],
+							[PostalCode],[PhoneNumber],[GenderID],[ETLRowID])
+	SELECT [p].[DateOfBirth], [p].[LastName], [p].[FirstName], [p].[Address1], [p].[Address2], [p].[City], [p].[StateID]
+			, [p].[PostalCode], [p].[PhoneNumber], [p].[GenderID], [p].[ETLRowID] 
+	FROM [#PatientImport] AS p WHERE [p].[RowNumber] = 1
+	SET @RowCountCheck = @@ROWCOUNT
+
+	CREATE TABLE #ProcessPatient (PatientID INT, DenseRank INT NOT NULL, ETLRowID VARCHAR(50) NOT NULL)
+	INSERT [#ProcessPatient] ([PatientID], [DenseRank], ETLRowID)
+	SELECT [p].[PatientID]
+			, [i].[DenseRank]
+			, [s].[RowID]
+	FROM   [etl].[StagedLakerFile] AS s
+			INNER JOIN [#PatientImport] AS i ON [i].[ETLRowID] = [s].[RowID]
+			LEFT JOIN [dbo].[Patient] AS [p] ON [s].[RowID] = [p].[ETLRowID];
+
+	CREATE TABLE #UpdatePatient (ETLRowID VARCHAR(50) NOT NULL, PatientID INT NULL);
+	INSERT #UpdatePatient ([ETLRowID],[PatientID])
+	SELECT [pp].ETLRowID
+			, PatientID = MIN([pp].[PatientID]) OVER ( 
+					PARTITION BY [pp].[DenseRank] ORDER BY [pp].[DenseRank]
+					ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING )
+	FROM   [#ProcessPatient] AS [pp]
+			
+	IF EXISTS
+	(
+		SELECT *
+		FROM   #UpdatePatient AS [tp]
+		WHERE  [tp].[ETLRowID] IS NULL
+				OR [tp].[PatientID] IS NULL
+	)
+		BEGIN
+			IF @@TRANCOUNT > 0
+				ROLLBACK
+			RAISERROR(N'Error. There are not supposed to be any NULL PatientID''s or ETLRowID''s in the transient table', 16, 1) WITH NOWAIT
+			RETURN
+		END
+
+	UPDATE s SET s.PatientID = u.PatientID
+	FROM   [etl].[StagedLakerFile] s WITH (TABLOCKX)
+			INNER JOIN #UpdatePatient u ON [s].[RowID] = u.[ETLRowID]
+
+	-- Patient QA Check
+	EXEC(N'ALTER TABLE [etl].[StagedLakerFile] ALTER COLUMN PatientID INT NOT NULL')
+
+	-- Change it back
+	EXEC(N'ALTER TABLE [etl].[StagedLakerFile] ALTER COLUMN PatientID INT NULL')
+			
+	-- Patient QA Check
+	IF @RowCountCheck != (SELECT COUNT(DISTINCT slf.[PatientID]) FROM [etl].[StagedLakerFile] AS [slf])
+		BEGIN
+			IF @@TRANCOUNT > 0
+				ROLLBACK;
+			RAISERROR(N'Error. The QA check for the count of rows inserted into Patient, and the distinct count of PatientID''s found in the StagedLakerFile table failed.', 16, 1) WITH NOWAIT;
+			RETURN;
+		END
+
+	/********************************************************************************************
+	Phew... that was a hard one. End Patient Section
+	********************************************************************************************/
+
+	/********************************************************************************************
+	Begin Claim Section
+	Notes: We have an issue with the unique identifier "ClaimNumber + PersonCode".
+	SELECT DISTINCT [s].[8],[s].[9]--,[s].[19],[s].[22],[s].[25],[s].[125],s.[PatientID],s.[PayorID],s.[AdjustorID]
+	FROM   [etl].[StagedLakerFile] AS s
+	WHERE  s.[PatientID] IS NOT NULL
+			AND s.[PayorID] IS NOT NULL
+	-- Returns 863 records, but when I add the rest of the necessary columns, this duplicates some rows
+	SELECT DISTINCT [s].[8],[s].[9],[s].[19],[s].[22],[s].[25],[s].[125],s.[PatientID],s.[PayorID],s.[AdjustorID]
+	FROM   [etl].[StagedLakerFile] AS s
+	WHERE  s.[PatientID] IS NOT NULL
+			AND s.[PayorID] IS NOT NULL
+	-- And this now returns 874 Records. Query to find the dupes:
+	SELECT   [c].[8]
+			, [c].[9]
+			, COUNT(*)
+	FROM     (   SELECT [s].[8]
+						, [s].[9]
+						, [s].[19]
+						, [s].[22]
+						, [s].[25]
+						, [s].[125]
+						, [s].[PatientID]
+						, [s].[PayorID]
+						, [s].[AdjustorID]
+						, RowID = ROW_NUMBER() OVER ( PARTITION BY [s].[8]
+																, [s].[9]
+																, [s].[19]
+																, [s].[22]
+																, [s].[25]
+																, [s].[125]
+																, [s].[PatientID]
+																, [s].[PayorID]
+																, [s].[AdjustorID]
+													ORDER BY [s].[8]
+													)
+						, DenseRank = DENSE_RANK() OVER ( ORDER BY [s].[8]
+																, [s].[9]
+																, [s].[19]
+																, [s].[22]
+																, [s].[25]
+																, [s].[125]
+																, [s].[PatientID]
+																, [s].[PayorID]
+																, [s].[AdjustorID]
+														)
+						, [s].[StageID]
+					FROM   [etl].[StagedLakerFile] AS s
+					WHERE  [s].[PatientID] IS NOT NULL
+						AND [s].[PayorID] IS NOT NULL
+				) AS c
+	WHERE    [c].[RowID] = 1
+	GROUP BY [c].[8]
+			, [c].[9]
+	HAVING   COUNT(*) > 1
+	********************************************************************************************/
+	CREATE TABLE #ClaimImport(
+				[8] [varchar](8000) NULL,
+				[9] [varchar](8000) NULL,
+				[19] [varchar](8000) NULL,
+				[22] [varchar](8000) NULL,
+				[25] [varchar](8000) NULL,
+				[125] [varchar](8000) NULL,
+				[PatientID] [int] NULL,
+				[PayorID] [int] NOT NULL,
+				[AdjustorID] [int] NULL,
+				[RowNumber] [int] NULL,
+				[DenseRank] [int] NULL,
+				[ETLRowID] VARCHAR(50) NOT NULL)
+	INSERT INTO [#ClaimImport] ([8],[9],[19],[22],[25],[125],[PatientID],[PayorID],[AdjustorID],[RowNumber],[DenseRank],[ETLRowID])
+	SELECT [s].[8],[s].[9],[s].[19],[s].[22],[s].[25],[s].[125],s.[PatientID],s.[PayorID],s.[AdjustorID]
+	,ROW_NUMBER() OVER (PARTITION BY [s].[8],[s].[9],[s].[19],[s].[22],[s].[25],[s].[125],s.[PatientID],s.[PayorID],s.[AdjustorID] ORDER BY [s].[8]) RowNumber
+	,DENSE_RANK() OVER (ORDER BY [s].[8],[s].[9],[s].[19],[s].[22],[s].[25],[s].[125],s.[PatientID],s.[PayorID],s.[AdjustorID]) DenseRank, s.[RowID]
+	FROM   [etl].[StagedLakerFile] AS s
+	WHERE  1 = 1
+			AND s.[PatientID] IS NOT NULL
+			AND s.[PayorID] IS NOT NULL
+
+	-- Claim Import Statement
+	INSERT [dbo].[Claim] ([ClaimNumber]
+				, [PersonCode]
+				, [DateOfInjury]
+				, [RelationCode]
+				, [PreviousClaimNumber] -- Note, need to check on the mapping of "PolicyNum"
+				, [TermDate]
+				, [PatientID]
+				, [PayorID]
+				, [AdjusterID]
+				, [ETLRowID]
+				, [IsFirstParty] -- Check on this, doesn't allow NULLs and is not in the mapping file.
+				)
+	SELECT	[ci].[8],[ci].[9],[ci].[19],[ci].[22],[ci].[25],[ci].[125],[ci].[PatientID],[ci].[PayorID],[ci].[AdjustorID],[ci].[ETLRowID], 1
+	FROM	[#ClaimImport] AS [ci] 
+	WHERE	[ci].[RowNumber] = 1
+	SET @RowCountCheck = @@ROWCOUNT
+			
+	CREATE TABLE #ProcessClaim (ClaimID INT, DenseRank INT NOT NULL, ETLRowID VARCHAR(50) NOT NULL)
+	INSERT #ProcessClaim ([ClaimID], [DenseRank], ETLRowID)
+	SELECT [c].[ClaimID]
+			, [i].[DenseRank]
+			, [s].[RowID]
+	FROM   [etl].[StagedLakerFile] AS s
+			INNER JOIN [#ClaimImport] AS i ON [i].[ETLRowID] = [s].[RowID]
+			LEFT JOIN [dbo].[Claim] AS [c] ON [s].[RowID] = [c].[ETLRowID];
+
+	CREATE TABLE #UpdateClaim (ETLRowID VARCHAR(50) NOT NULL, ClaimID INT NOT NULL)
+	INSERT #UpdateClaim ([ETLRowID],[ClaimID])
+	SELECT [pc].ETLRowID
+			, ClaimID = MIN([pc].[ClaimID]) OVER ( 
+					PARTITION BY [pc].[DenseRank] ORDER BY [pc].[DenseRank]
+					ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
+	FROM   [#ProcessClaim] AS [pc]
+			
+	UPDATE [s]
+	SET    [s].[ClaimID] = [c].[ClaimID]
+	FROM   #UpdateClaim AS c
+			INNER JOIN [etl].[StagedLakerFile] AS s WITH (TABLOCKX) ON [s].[RowID] = [c].[ETLRowID];
+			
+	-- QA Check, make sure that there are NO records with an empty Claim ID
+	EXEC(N'ALTER TABLE [etl].[StagedLakerFile] ALTER COLUMN [ClaimID] INT NOT NULL')
+
+	-- Ok, set it back.
+	EXEC(N'ALTER TABLE [etl].[StagedLakerFile] ALTER COLUMN [ClaimID] INT NULL')
+
+	-- Claim QA Check
+	IF @RowCountCheck != (SELECT COUNT(DISTINCT slf.[ClaimID]) FROM [etl].[StagedLakerFile] AS [slf])
+		BEGIN
+			IF @@TRANCOUNT > 0
+				ROLLBACK;
+			RAISERROR(N'Error. The QA check for the count of rows inserted into Claim, and the distinct count of ClaimID''s found in the StagedLakerFile table failed.', 16, 1) WITH NOWAIT;
+			RETURN;
+		END
+			
+	/********************************************************************************************
+	End Claim Section
+	********************************************************************************************/
+	/********************************************************************************************
+	Begin Invoice Section
+	********************************************************************************************/
+	CREATE TABLE #InvoiceImport (ARItemKey VARCHAR(1),Amount MONEY,InvoiceNumber VARCHAR(8000),InvoiceDate VARCHAR(8000),[PayorID] INT NOT NULL
+								,[ClaimID] INT NOT NULL, RowNumber INT NOT NULL, DenseRank INT NOT NULL, ETLRowID VARCHAR(50) NOT NULL)
+	INSERT INTO [#InvoiceImport] ([ARItemKey],[Amount],[InvoiceNumber],[InvoiceDate],[PayorID],[ClaimID],RowNumber,[DenseRank],[ETLRowID])
+	SELECT '' -- Have to check on Mapping of ARIItemKey
+		,  0 -- Have to check on Mapping of Amount
+		, s.[4],s.[5],s.[PayorID],[s].[ClaimID]
+		,ROW_NUMBER() OVER (PARTITION BY s.[4],s.[5],s.[PayorID],[s].[ClaimID] ORDER BY [s].[4]) RowID
+		,DENSE_RANK() OVER (ORDER BY s.[4],s.[5],s.[PayorID],[s].[ClaimID]) DenseRank
+		,s.[RowID]
+	FROM   [etl].[StagedLakerFile] AS s
+	WHERE  1 = 1
+			AND s.[ClaimID] IS NOT NULL
+			AND [s].[4] IS NOT NULL
+			AND [s].[5] IS NOT NULL
+			AND [s].[PayorID] IS NOT NULL
+			
+	-- Invoice Import Statement
+	INSERT [dbo].[Invoice] ([ARItemKey],[Amount],[InvoiceNumber],[InvoiceDate],[ETLRowID])
+	SELECT [i].[ARItemKey],[i].[Amount],[i].[InvoiceNumber],[i].[InvoiceDate],[i].[ETLRowID]
+	FROM [#InvoiceImport] i WHERE i.RowNumber = 1
+	SET @RowCountCheck = @@ROWCOUNT
+			
+	CREATE TABLE #ProcessInvoice ([InvoiceID] INT, DenseRank INT NOT NULL, ETLRowID VARCHAR(50) NOT NULL)
+	INSERT #ProcessInvoice ([InvoiceID], [DenseRank], ETLRowID)
+	SELECT [inv].[InvoiceID]
+			, [i].[DenseRank]
+			, [s].[RowID]
+	FROM   [etl].[StagedLakerFile] AS s
+			INNER JOIN [#InvoiceImport] AS i ON [i].[ETLRowID] = [s].[RowID]
+			LEFT JOIN [dbo].[Invoice] AS [inv] ON [s].[RowID] = [inv].[ETLRowID];
+	
+	CREATE TABLE #UpdateInvoice (ETLRowID VARCHAR(50) NOT NULL, InvoiceID INT NOT NULL)
+	INSERT #UpdateInvoice ([ETLRowID],[InvoiceID])
+	SELECT [inv].ETLRowID
+			, InvoiceID = MIN([inv].[InvoiceID]) OVER ( 
+					PARTITION BY [inv].[DenseRank] ORDER BY [inv].[DenseRank]
+					ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING )
+	FROM   [#ProcessInvoice] AS [inv]
+	
+	UPDATE [s]
+	SET    [s].InvoiceID = [c].InvoiceID
+	FROM   #UpdateInvoice AS c
+		   INNER JOIN [etl].[StagedLakerFile] AS s WITH (TABLOCKX) ON [s].[RowID] = [c].[ETLRowID];
+
+	-- Invoice QA Check
+	IF @RowCountCheck != (SELECT COUNT(DISTINCT s.InvoiceID) FROM [etl].[StagedLakerFile] AS s)
+		BEGIN
+			IF @@TRANCOUNT > 0
+				ROLLBACK;
+			RAISERROR(N'Error. The QA check for the count of rows inserted into Invoice, and the distinct count of InvoiceID''s found in the StagedLakerFile table failed.', 16, 1) WITH NOWAIT;
+			RETURN;
+		END
+
+	/********************************************************************************************
+	End Invoice Section
+	********************************************************************************************/
+	
+	/********************************************************************************************
+	Begin Prescription Section
+	********************************************************************************************/
+	INSERT INTO [dbo].[Prescription] ([ClaimID],[DateSubmitted],[RxNumber],[DateFilled],[RefillDate],[RefillNumber],[MONY],
+			[DAW],[Quantity],[DaySupply],[NDC],[LabelName],[GPI],[BillIngrCost],[BillDispFee],[BilledTax],[BilledCopay],
+			[BilledAmount],[PayIngrCost],[PayDispFee],[PayTax],[PayableAmount],[DEA],[PrescriberNPI],[AWPUnit],[Usual],
+			[Compound],[Strength],[GPIGenName],[TheraClass],[Generic],[PharmacyNABP],[Prescriber],[TransactionType],[TranID],
+			[InvoiceID],[ETLRowID])
+	SELECT	s.[ClaimID],s.[3],s.[60],s.[61],s.[62],s.[63],s.[64],s.[65],s.[66],s.[67],s.[68],s.[69],s.[70],s.[71],s.[72],s.[73]
+			,s.[74],s.[75],s.[76],s.[77],s.[78],s.[79],s.[80],s.[81],s.[105],s.[122],
+			ISNULL(s.[123],'') -- TODO: Remove at some point, this column is non-nullable.
+			,s.[137],s.[143],s.[146]
+			,'Y','','','','',s.[InvoiceID],s.[RowID] -- Question for Adam: this isn't in the mapping file. [Generic],[PharmacyNABP]
+	FROM	[etl].[StagedLakerFile] AS s
+
+	UPDATE e SET e.[PrescriptionID] = [p].[PrescriptionID]
+	FROM   [dbo].[Prescription] AS [p]
+			INNER JOIN [etl].[StagedLakerFile] AS e ON [e].[RowID] = [p].[ETLRowID]
+	SET @RowCountCheck = @@ROWCOUNT
+
+	-- QA check, ensure that there is a Prescription for every record.
+	EXEC(N'ALTER TABLE [etl].[StagedLakerFile] ALTER COLUMN PrescriptionID INT NOT NULL')
+
+	-- Ok, set it back.
+	EXEC(N'ALTER TABLE [etl].[StagedLakerFile] ALTER COLUMN PrescriptionID INT NULL')
+			
+	-- Prescription QA Check
+	IF (@RowCountCheck != (SELECT COUNT(*) FROM 
+			(SELECT DISTINCT s.[ClaimID],s.[3],s.[60],s.[61],s.[62],s.[63],s.[64],s.[65],s.[66],s.[67],
+			s.[68],s.[69],s.[70],s.[71],s.[72],s.[73]
+			,s.[74],s.[75],s.[76],s.[77],s.[78],s.[79],s.[80],s.[81],s.[105],s.[122],s.[123],s.[137],s.[143],s.[146]
+				FROM [etl].[StagedLakerFile] AS s
+				) AS a))
+		BEGIN
+			IF (@@TRANCOUNT > 0)
+				ROLLBACK TRANSACTION;
+			RAISERROR(N'Something went wrong. The total row count of the Staging table didn''t match the distinct count of Prescription columns.', 16, 1) WITH NOWAIT
+			RETURN
+		END
+
+	/********************************************************************************************
+	Begin Pharmacy Section
+	********************************************************************************************/
+	CREATE TABLE #PharmacyImport
+	(
+		[89] [varchar] (500) NOT NULL,
+		[90] [varchar] (8000) NULL,
+		[91] [varchar] (8000) NULL,
+		[92] [varchar] (8000) NULL,
+		[93] [varchar] (8000) NULL,
+		[94] [varchar] (8000) NULL,
+		[StateID] [int] NULL,
+		[96] [varchar] (8000) NULL,
+		[97] [varchar] (8000) NULL,
+		[RowNumber] [int] NULL,
+		[DenseRank] [int] NULL,
+		ETLRowID VARCHAR(50) NOT NULL,
+		INDEX idxTempPharmacyImport NONCLUSTERED ([89])
+	)
+	INSERT INTO [#PharmacyImport] ([89],[90],[91],[92],[93],[94],[StateID],[96],[97],[RowNumber],[DenseRank],ETLRowID)
+	SELECT [s].[89],[s].[90],[s].[91],[s].[92],[s].[93],[s].[94],[us].[StateID],[s].[96],[s].[97]
+		,ROW_NUMBER() OVER (PARTITION BY [s].[89],[s].[90],[s].[91],[s].[92],[s].[93],[s].[94],[us].[StateID],[s].[96],[s].[97] ORDER BY [s].[89]) RowID
+		,DENSE_RANK() OVER (ORDER BY [s].[89],[s].[90],[s].[91],[s].[92],[s].[93],[s].[94],[us].[StateID],[s].[96],[s].[97]) DenseRank, 
+		[s].[RowID]
+	FROM [etl].[StagedLakerFile] AS [s]
+			LEFT JOIN [dbo].[UsState] AS [us] ON [us].[StateCode] = [s].[95]
+	WHERE [s].[89] IS NOT NULL
+			OR [s].[90] IS NOT NULL
+			OR [s].[91] IS NOT NULL
+			OR [s].[92] IS NOT NULL
+			OR [s].[93] IS NOT NULL
+			OR [s].[94] IS NOT NULL
+			OR [us].[StateID] IS NOT NULL
+			OR [s].[96] IS NOT NULL
+			OR [s].[97] IS NOT NULL
+
+	INSERT INTO [dbo].[Pharmacy] ([NABP],[NPI],[PharmacyName],[Address1],[Address2],[City],[StateID],[PostalCode],[DispType], [ETLRowID])
+	SELECT	[p].[89],[p].[90],[p].[91],[p].[92],[p].[93],[p].[94],[p].[StateID],[p].[96],util.udfTrimLeadingZeros([p].[97]),[p].[ETLRowID]
+	FROM	[#PharmacyImport] AS [p]
+	WHERE	[p].[RowNumber] = 1
+	SET @RowCountCheck = @@ROWCOUNT
+
+	CREATE TABLE #ProcessPharmacy ([PharmacyID] INT, DenseRank INT NOT NULL, ETLRowID VARCHAR(50) NOT NULL)
+	INSERT #ProcessPharmacy ([PharmacyID],[DenseRank],ETLRowID)
+	SELECT [p].[PharmacyID]
+			, [i].[DenseRank]
+			, [s].[RowID]
+	FROM   [etl].[StagedLakerFile] AS s
+			INNER JOIN [#PharmacyImport] AS i ON [i].[ETLRowID] = [s].[RowID]
+			LEFT JOIN [dbo].[Pharmacy] AS [p] ON [s].[RowID] = [p].[ETLRowID];
+
+	WITH WindowingMagicCTE AS
+	(
+		SELECT ph.ETLRowID
+				, PharmacyID = MIN(ph.[PharmacyID]) OVER (
+						PARTITION BY ph.[DenseRank] ORDER BY ph.[DenseRank]
+						ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
+		FROM   #ProcessPharmacy AS ph WHERE ph.[PharmacyID] IS NOT NULL AND ph.ETLRowID IS NOT NULL
+	)
+	UPDATE [s]
+	SET    [s].[PharmacyID] = [c].[PharmacyID]
+	FROM   [WindowingMagicCTE] AS c
+			INNER JOIN [etl].[StagedLakerFile] AS s WITH (TABLOCKX) ON [c].[ETLRowID] = [s].[RowID]
+	SET @RowCountCheck = @@ROWCOUNT
+			
+	-- Pharmacy QA Check
+	IF @RowCountCheck != (SELECT COUNT(DISTINCT s.PharmacyID) FROM [etl].[StagedLakerFile] AS s)
+		BEGIN
+			IF @@TRANCOUNT > 0
+				ROLLBACK;
+			RAISERROR(N'Error. The QA check for the count of rows inserted into Pharmacy, and the distinct count of PharmacyID''s found in the StagedLakerFile table failed.', 16, 1) WITH NOWAIT;
+			RETURN;
+		END
+
+	IF (SELECT COUNT(DISTINCT [p].[NPI]) FROM [dbo].[Pharmacy] AS [p]) != @RowCountCheck
+		BEGIN
+			IF @@TRANCOUNT > 0
+				ROLLBACK;
+			RAISERROR(N'Error. The QA check for the count of unique NPI numbers for a Pharmacy did not match the total quantity inserted for Pharmacies', 16, 1) WITH NOWAIT
+			RETURN
+		END
+			
+	/********************************************************************************************
+	End Pharmacy Section
+	********************************************************************************************/
+
+	/********************************************************************************************
+	Begin AcctPayables Section
+	********************************************************************************************/
+	INSERT INTO [dbo].[AcctPayable] ([CheckNumber],[CheckDate],[AmountPaid],[ClaimID],[InvoiceID], [ETLRowID])
+	SELECT [s].[6]
+			, [s].[7]
+			, 0
+			, [s].[ClaimID]
+			, [s].[InvoiceID]
+			, [s].[RowID]
+	FROM   [etl].[StagedLakerFile] AS [s]
+	WHERE  1 = 1
+			AND [s].[InvoiceID] IS NOT NULL
+			AND [s].[6] IS NOT NULL
+	SET @RowCountCheck = @@ROWCOUNT
+
+	UPDATE s SET s.AcctPayableID = [p].[AcctPayableID]
+	FROM   [dbo].[AcctPayable] AS [p]
+			INNER JOIN [etl].[StagedLakerFile] AS [s] ON [s].[RowID] = [p].[ETLRowID]
+	IF @@ROWCOUNT != @RowCountCheck
+		BEGIN
+			IF @@TRANCOUNT > 0
+				ROLLBACK;
+			RAISERROR(N'Error. The count of PaymentIDs updated in the Staging table did not match the count of Payments imported.', 16, 1) WITH NOWAIT
+			RETURN
+		END
+
+	IF @RowCountCheck != (SELECT COUNT(DISTINCT AcctPayableID) FROM [etl].[StagedLakerFile])
+		BEGIN
+			IF @@TRANCOUNT > 0
+				ROLLBACK;
+			RAISERROR(N'Error. The count of PaymentIDs updated in the Staging table did not match the count of Payments imported.', 16, 1) WITH NOWAIT
+			RETURN
+		END
+
+	/********************************************************************************************
+	End Payments Section
+	********************************************************************************************/
+
+	/********************************************************************************************
+	*********************************************************************************************
+	End ETL
+	*********************************************************************************************
+	********************************************************************************************/
+	-- Re-create indexed view.
+	EXEC [dbo].[uspCreateIndexedPrescriptionNoteView]
+END
+GO
diff --git a/Stored Procedures/util.uspSmarterTruncateTable.sql b/Stored Procedures/util.uspSmarterTruncateTable.sql
new file mode 100644
index 0000000..171bd23
--- /dev/null
+++ b/Stored Procedures/util.uspSmarterTruncateTable.sql
@@ -0,0 +1,122 @@
+SET QUOTED_IDENTIFIER ON
+GO
+SET ANSI_NULLS ON
+GO
+-- =================================================================================================================================
+-- Change:      8/03/2011: Added schema name to generated SQL so proc will work with base schema objects
+--                  The value passed in for @TableName should include the base schema qualifier
+--              8/23/2011: Modified WHERE clause in subquery to add "f.parent_object_id = sob.parent_obj"
+--                  The old code was comparing names only, without schema. This produced duplicates when there were objects
+--                  in multiple schemas with the same name (i.e. dbo.Titles and base.Titles)
+-- =================================================================================================================================
+CREATE PROCEDURE [util].[uspSmarterTruncateTable]  --'etl.Accounts'
+     @TableName VARCHAR(100)  
+AS  
+BEGIN  
+	 IF @TableName LIKE '%[%' OR @TableName LIKE '%]%'
+		SET @TableName = REPLACE(REPLACE(@TableName, '[', ''), ']', '')
+     DECLARE @UQTableName VARCHAR(100) = ( SELECT SUBSTRING(@TableName, CHARINDEX('.', @TableName) + 1, LEN(@TableName)) )
+     DECLARE @SchemaName VARCHAR(20) = ( SELECT LEFT(@TableName, CHARINDEX('.', @TableName)- 1 ))
+     DECLARE @NewLineChar AS CHAR(2) = CHAR(13) + CHAR(10)
+     DECLARE @foreignKeyName sysname, @foreignKeyTableName sysname, @createScript VARCHAR(MAX)
+     DECLARE @dropKeysSQL VARCHAR(MAX) = '', @createKeysSQL VARCHAR(MAX) = ''
+
+     DECLARE rename_cursor CURSOR FOR
+     WITH AllPKs AS (
+           SELECT OBJECT_SCHEMA_NAME(sob.parent_obj) + '.' + OBJECT_NAME(sob.parent_obj) AS ForeignKeyTableName, 
+                  sob.name AS ForeignKeyName,
+            CAST(STUFF(( SELECT  DISTINCT
+                                ';ALTER TABLE ' + OBJECT_SCHEMA_NAME(f.parent_object_id) + '.'
+                                                + OBJECT_NAME(f.parent_object_id) + ' ADD CONSTRAINT '
+                                + f.name + ' FOREIGN KEY ('  
+                                + SUBSTRING(( SELECT    ',' + COL_NAME(fci.parent_object_id,  
+                                                                       fci.parent_column_id)  
+                                              FROM      sys.[foreign_key_columns] fci  
+                                              WHERE     fci.[constraint_object_id] = fc.[constraint_object_id]  
+                                            FOR  
+                                              XML PATH('')  
+                                            ), 2,  
+                                            LEN(( SELECT    ',' + COL_NAME(fci.parent_object_id,  
+                                                                           fci.parent_column_id)  
+                                                  FROM      sys.[foreign_key_columns] fci  
+                                                  WHERE     fci.[constraint_object_id] = fc.[constraint_object_id]  
+                                                FOR  
+                                                  XML PATH('')  
+                                                ))) + ')' + ' REFERENCES ['  
+                                + OBJECT_SCHEMA_NAME(f.referenced_object_id) + '].[' + OBJECT_NAME(f.referenced_object_id) + '] ('  
+                                + SUBSTRING(( SELECT   ',' + COL_NAME(fci.[referenced_object_id],  
+                                                                      fci.[referenced_column_id])  
+                                               FROM     sys.[foreign_key_columns] fci  
+                                               WHERE    fci.[constraint_object_id] = fc.[constraint_object_id]  
+                                             FOR  
+                                               XML PATH('')  
+                                             ), 2,  
+                                             LEN(( SELECT   ',' + COL_NAME(fci.[referenced_object_id],  
+                                                                           fci.[referenced_column_id])  
+                                                   FROM     sys.[foreign_key_columns] fci  
+                                                   WHERE    fci.[constraint_object_id] = fc.[constraint_object_id]  
+                                                 FOR  
+                                                   XML PATH('')  
+                                                 ))) + ')' AS Scripts  
+                         FROM   sys.foreign_keys AS f  
+                                INNER JOIN sys.foreign_key_columns AS fc ON f.OBJECT_ID = fc.constraint_object_id  
+                         WHERE  --OBJECT_NAME(f.parent_object_id) = OBJECT_NAME(sob.parent_obj)  
+								f.parent_object_id = sob.parent_obj
+                                AND f.name = sob.NAME  
+                       --FOR  
+                         --XML PATH('')  
+                                   ), 1, 1, '') AS VARCHAR(5000)) AS CreateScript  
+           FROM sysobjects sob  
+           JOIN sysobjects c   
+                ON sob.parent_obj = c.id  
+           JOIN sysreferences r   
+                ON sob.id =  r.constid  
+           JOIN sysobjects p   
+                ON r.rkeyid = p.id  
+           WHERE sob.[type] =  'F' AND  p.name = @UQTableName --AND OBJECT_SCHEMA_NAME(sob.parent_obj) = @SchemaName
+     )
+     SELECT * FROM AllPKs  
+
+     OPEN rename_cursor  
+
+     FETCH NEXT FROM rename_cursor   
+     INTO @foreignKeyTableName, @foreignKeyName, @createScript  
+
+     WHILE @@FETCH_STATUS = 0  
+     BEGIN  
+        SELECT @dropKeysSQL = @dropKeysSQL + ' ALTER TABLE ' + @foreignKeyTableName + ' DROP CONSTRAINT ' + @foreignKeyName + @NewLineChar  
+        SELECT @createKeysSQL = @createKeysSQL + ' ' + @createScript + @NewLineChar  
+        FETCH NEXT FROM rename_cursor   
+        INTO @foreignKeyTableName, @foreignKeyName, @createScript  
+     END  
+
+     CLOSE rename_cursor  
+     DEALLOCATE rename_cursor  
+
+
+     -- STEP 1: Start the transaction  
+     BEGIN TRANSACTION  
+
+         DECLARE @SQL NVARCHAR(MAX)   
+         DECLARE @intTableCount INT  
+         SELECT @SQL = @DropKeysSQL + ' TRUNCATE TABLE ' + @tableName + ' ' + @NewLineChar + @CreateKeysSQL     
+         PRINT '----- Running Script -----' + @NewLineChar
+         PRINT @SQL
+         PRINT '----- End of Script -----' + @NewLineChar
+
+         PRINT 'NOTE: If error occurs, it may be nessassary to truncate a referencing tables data first.' + @NewLineChar
+         EXEC sp_executesql @SQL, N'@intTableCount INT OUTPUT', @intTableCount OUTPUT
+
+     IF (@intTableCount <> 0)
+     BEGIN
+           PRINT 'Rolling Back the Transaction.'
+           ROLLBACK TRANSACTION
+     END
+     ELSE
+     BEGIN
+           COMMIT TRANSACTION
+           PRINT 'Truncated Successfully.'
+     END
+END
+
+GO
diff --git a/Tables/dbo.AcctPayable.sql b/Tables/dbo.AcctPayable.sql
new file mode 100644
index 0000000..0487b13
--- /dev/null
+++ b/Tables/dbo.AcctPayable.sql
@@ -0,0 +1,26 @@
+CREATE TABLE [dbo].[AcctPayable]
+(
+[AcctPayableID] [int] NOT NULL IDENTITY(1, 1),
+[CheckNumber] [varchar] (100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[CheckDate] [date] NOT NULL,
+[AmountPaid] [money] NOT NULL,
+[ClaimID] [int] NOT NULL,
+[InvoiceID] [int] NOT NULL,
+[CreatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfAcctPayableCreatedOnUTC] DEFAULT (sysutcdatetime()),
+[UpdatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfAcctPayableUpdatedOnUTC] DEFAULT (sysutcdatetime()),
+[DataVersion] [timestamp] NOT NULL,
+[ETLRowID] [varchar] (50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[AcctPayable] ADD CONSTRAINT [pkAcctPayable] PRIMARY KEY CLUSTERED  ([AcctPayableID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxAcctPayableClaimIDIncludeAll] ON [dbo].[AcctPayable] ([ClaimID]) INCLUDE ([AcctPayableID], [AmountPaid], [CheckDate], [CheckNumber], [CreatedOnUTC], [InvoiceID], [UpdatedOnUTC]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+ALTER TABLE [dbo].[AcctPayable] ADD CONSTRAINT [fkAcctPayableClaimIDClaimClaimID] FOREIGN KEY ([ClaimID]) REFERENCES [dbo].[Claim] ([ClaimID])
+GO
+ALTER TABLE [dbo].[AcctPayable] ADD CONSTRAINT [fkAcctPayableInvoiceIDInvoiceInvoiceID] FOREIGN KEY ([InvoiceID]) REFERENCES [dbo].[Invoice] ([InvoiceID])
+GO
diff --git a/Tables/dbo.Adjustor.sql b/Tables/dbo.Adjustor.sql
new file mode 100644
index 0000000..0ddf35d
--- /dev/null
+++ b/Tables/dbo.Adjustor.sql
@@ -0,0 +1,27 @@
+CREATE TABLE [dbo].[Adjustor]
+(
+[AdjustorID] [int] NOT NULL IDENTITY(1, 1),
+[PayorID] [int] NOT NULL,
+[AdjustorName] [varchar] (255) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[PhoneNumber] [varchar] (30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[FaxNumber] [varchar] (30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[EmailAddress] [varchar] (155) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[Extension] [varchar] (10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[CreatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfAdjustorCreatedOnUTC] DEFAULT (sysutcdatetime()),
+[UpdatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfAdjustorUpdatedOnUTC] DEFAULT (sysutcdatetime()),
+[DataVersion] [timestamp] NOT NULL,
+[ETLRowID] [varchar] (50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[Adjustor] ADD CONSTRAINT [pkAdjustor] PRIMARY KEY CLUSTERED  ([AdjustorID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+CREATE UNIQUE NONCLUSTERED INDEX [idxUqAdjustorAdjustorNamePayorID] ON [dbo].[Adjustor] ([AdjustorName], [PayorID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxAdjustorPayorIDIncludeAll] ON [dbo].[Adjustor] ([PayorID]) INCLUDE ([AdjustorID], [AdjustorName], [CreatedOnUTC], [DataVersion], [EmailAddress], [Extension], [FaxNumber], [PhoneNumber], [UpdatedOnUTC]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+ALTER TABLE [dbo].[Adjustor] ADD CONSTRAINT [fkAdjustorPayorIDPayorPayorID] FOREIGN KEY ([PayorID]) REFERENCES [dbo].[Payor] ([PayorID])
+GO
diff --git a/Tables/dbo.AspNetUsers.sql b/Tables/dbo.AspNetUsers.sql
new file mode 100644
index 0000000..c13d2c5
--- /dev/null
+++ b/Tables/dbo.AspNetUsers.sql
@@ -0,0 +1,27 @@
+CREATE TABLE [dbo].[AspNetUsers]
+(
+[ID] [nvarchar] (128) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[FirstName] [nvarchar] (100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[LastName] [nvarchar] (100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[RegisteredDate] [datetime] NOT NULL,
+[UserName] [nvarchar] (256) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[Email] [nvarchar] (256) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[EmailConfirmed] [bit] NOT NULL,
+[PasswordHash] [nvarchar] (4000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[SecurityStamp] [nvarchar] (4000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[PhoneNumber] [varchar] (30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[PhoneNumberConfirmed] [bit] NOT NULL,
+[TwoFactorEnabled] [bit] NOT NULL,
+[LockoutEndDateUtc] [datetime] NULL,
+[LockoutEnabled] [bit] NOT NULL,
+[AccessFailedCount] [int] NOT NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[AspNetUsers] ADD CONSTRAINT [pkAspNetUsers] PRIMARY KEY CLUSTERED  ([ID]) WITH (DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+CREATE UNIQUE NONCLUSTERED INDEX [idxUqAspNetUsersName] ON [dbo].[AspNetUsers] ([UserName]) WITH (DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
diff --git a/Tables/dbo.Claim.sql b/Tables/dbo.Claim.sql
new file mode 100644
index 0000000..9edf8f9
--- /dev/null
+++ b/Tables/dbo.Claim.sql
@@ -0,0 +1,46 @@
+CREATE TABLE [dbo].[Claim]
+(
+[ClaimID] [int] NOT NULL IDENTITY(1, 1),
+[PolicyNumber] [varchar] (255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[DateOfInjury] [datetime2] NULL,
+[IsFirstParty] [bit] NOT NULL,
+[ClaimNumber] [varchar] (255) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[PreviousClaimNumber] [varchar] (255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[PersonCode] [int] NULL,
+[PayorID] [int] NOT NULL,
+[AdjusterID] [int] NULL,
+[JurisdictionStateID] [int] NULL,
+[RelationCode] [tinyint] NULL,
+[TermDate] [datetime2] NULL,
+[UniqueClaimNumber] AS ([ClaimNumber]+isnull('-'+CONVERT([char](2),[PersonCode],(0)),'')),
+[PatientID] [int] NOT NULL,
+[CreatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfClaimCreatedOnUTC] DEFAULT (sysutcdatetime()),
+[UpdatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfClaimUpdatedOnUTC] DEFAULT (sysutcdatetime()),
+[DataVersion] [timestamp] NOT NULL,
+[ETLRowID] [varchar] (50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[Claim] ADD CONSTRAINT [ckClaimRelationCode] CHECK (([RelationCode]>=(1) AND [RelationCode]<=(9)))
+GO
+ALTER TABLE [dbo].[Claim] ADD CONSTRAINT [pkClaim] PRIMARY KEY CLUSTERED  ([ClaimID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxClaimAdjusterID] ON [dbo].[Claim] ([AdjusterID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxClaimJurisdictionStateID] ON [dbo].[Claim] ([JurisdictionStateID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxClaimPatientIDPatientPatientID] ON [dbo].[Claim] ([PatientID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxClaimPayorIDIncludes] ON [dbo].[Claim] ([PayorID]) INCLUDE ([AdjusterID], [ClaimID], [ClaimNumber], [CreatedOnUTC], [DateOfInjury], [IsFirstParty], [JurisdictionStateID], [PersonCode], [PolicyNumber], [PreviousClaimNumber], [RelationCode], [TermDate], [UniqueClaimNumber], [UpdatedOnUTC]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+ALTER TABLE [dbo].[Claim] ADD CONSTRAINT [fkClaimAdjusterIDAdjustorAdjustorID] FOREIGN KEY ([AdjusterID]) REFERENCES [dbo].[Adjustor] ([AdjustorID])
+GO
+ALTER TABLE [dbo].[Claim] ADD CONSTRAINT [fkClaimJurisdictionStateIDUsStateStateID] FOREIGN KEY ([JurisdictionStateID]) REFERENCES [dbo].[UsState] ([StateID])
+GO
+ALTER TABLE [dbo].[Claim] ADD CONSTRAINT [fkClaimPatientIDPatientPatientID] FOREIGN KEY ([PatientID]) REFERENCES [dbo].[Patient] ([PatientID])
+GO
+ALTER TABLE [dbo].[Claim] ADD CONSTRAINT [fkClaimPayorIDPayorPayorID] FOREIGN KEY ([PayorID]) REFERENCES [dbo].[Payor] ([PayorID])
+GO
diff --git a/Tables/dbo.ClaimPayment.sql b/Tables/dbo.ClaimPayment.sql
new file mode 100644
index 0000000..142cbc3
--- /dev/null
+++ b/Tables/dbo.ClaimPayment.sql
@@ -0,0 +1,20 @@
+CREATE TABLE [dbo].[ClaimPayment]
+(
+[ClaimPaymentID] [int] NOT NULL IDENTITY(500000000, 1),
+[CheckNumber] [varchar] (50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[AmountPaid] [money] NOT NULL,
+[DatePosted] [date] NULL,
+[ClaimID] [int] NOT NULL,
+[CreatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfClaimPaymentCreatedOnUTC] DEFAULT (sysutcdatetime()),
+[UpdatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfClaimPaymentUpdatedOnUTC] DEFAULT (sysutcdatetime()),
+[DataVersion] [timestamp] NOT NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[ClaimPayment] ADD CONSTRAINT [pkClaimPayment] PRIMARY KEY CLUSTERED  ([ClaimPaymentID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+ALTER TABLE [dbo].[ClaimPayment] ADD CONSTRAINT [fkClaimPaymentClaimIDClaimClaimID] FOREIGN KEY ([ClaimID]) REFERENCES [dbo].[Claim] ([ClaimID])
+GO
diff --git a/Tables/dbo.Gender.sql b/Tables/dbo.Gender.sql
new file mode 100644
index 0000000..6d08821
--- /dev/null
+++ b/Tables/dbo.Gender.sql
@@ -0,0 +1,18 @@
+CREATE TABLE [dbo].[Gender]
+(
+[GenderID] [int] NOT NULL IDENTITY(1, 1),
+[GenderName] [varchar] (55) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[GenderCode] [varchar] (5) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[CreatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfGenderCreatedOnUTC] DEFAULT (sysutcdatetime()),
+[UpdatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfGenderUpdatedOnUTC] DEFAULT (sysutcdatetime()),
+[DataVersion] [timestamp] NOT NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[Gender] ADD CONSTRAINT [pkGender] PRIMARY KEY CLUSTERED  ([GenderID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+CREATE UNIQUE NONCLUSTERED INDEX [idxUqGenderGenderCode] ON [dbo].[Gender] ([GenderCode]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
diff --git a/Tables/dbo.Invoice.sql b/Tables/dbo.Invoice.sql
new file mode 100644
index 0000000..19a8243
--- /dev/null
+++ b/Tables/dbo.Invoice.sql
@@ -0,0 +1,26 @@
+CREATE TABLE [dbo].[Invoice]
+(
+[InvoiceID] [int] NOT NULL IDENTITY(1, 1),
+[InvoiceNumber] [varchar] (100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[InvoiceDate] [date] NOT NULL,
+[Amount] [money] NOT NULL,
+[PayorID] [int] NOT NULL,
+[ClaimID] [int] NOT NULL,
+[CreatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfInvoiceCreatedOnUTC] DEFAULT (sysutcdatetime()),
+[UpdatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfInvoiceUpdatedOnUTC] DEFAULT (sysutcdatetime()),
+[DataVersion] [timestamp] NOT NULL,
+[ETLRowID] [varchar] (50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[Invoice] ADD CONSTRAINT [pkInvoice] PRIMARY KEY CLUSTERED  ([InvoiceID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxInvoiceClaimIDClaimClaimIDIncludeAll] ON [dbo].[Invoice] ([ClaimID], [PayorID]) INCLUDE ([Amount], [CreatedOnUTC], [InvoiceDate], [InvoiceID], [InvoiceNumber], [UpdatedOnUTC]) WITH (DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+ALTER TABLE [dbo].[Invoice] ADD CONSTRAINT [fkInvoiceClaimIDClaimClaimID] FOREIGN KEY ([ClaimID]) REFERENCES [dbo].[Claim] ([ClaimID])
+GO
+ALTER TABLE [dbo].[Invoice] ADD CONSTRAINT [fkInvoicePayorIDPayorPayorID] FOREIGN KEY ([PayorID]) REFERENCES [dbo].[Payor] ([PayorID])
+GO
diff --git a/Tables/dbo.Patient.sql b/Tables/dbo.Patient.sql
new file mode 100644
index 0000000..a16ffa9
--- /dev/null
+++ b/Tables/dbo.Patient.sql
@@ -0,0 +1,33 @@
+CREATE TABLE [dbo].[Patient]
+(
+[PatientID] [int] NOT NULL IDENTITY(1, 1),
+[LastName] [varchar] (155) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[FirstName] [varchar] (155) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[Address1] [varchar] (255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[Address2] [varchar] (255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[City] [varchar] (155) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[PostalCode] [varchar] (100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[StateID] [int] NULL,
+[PhoneNumber] [varchar] (30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[AlternatePhoneNumber] [varchar] (30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[EmailAddress] [varchar] (155) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[DateOfBirth] [date] NULL,
+[GenderID] [int] NOT NULL,
+[CreatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPatientCreatedOnUTC] DEFAULT (sysutcdatetime()),
+[UpdatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPatientUpdatedOnUTC] DEFAULT (sysutcdatetime()),
+[DataVersion] [timestamp] NOT NULL,
+[ETLRowID] [varchar] (50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[Patient] ADD CONSTRAINT [pkPaitent] PRIMARY KEY CLUSTERED  ([PatientID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxPatientGenderID] ON [dbo].[Patient] ([GenderID], [StateID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+ALTER TABLE [dbo].[Patient] ADD CONSTRAINT [fkPatientGenderIDGenderGenderID] FOREIGN KEY ([GenderID]) REFERENCES [dbo].[Gender] ([GenderID])
+GO
+ALTER TABLE [dbo].[Patient] ADD CONSTRAINT [fkPatientStateIDUsStateStateID] FOREIGN KEY ([StateID]) REFERENCES [dbo].[UsState] ([StateID])
+GO
diff --git a/Tables/dbo.Payment.sql b/Tables/dbo.Payment.sql
new file mode 100644
index 0000000..520b6bb
--- /dev/null
+++ b/Tables/dbo.Payment.sql
@@ -0,0 +1,23 @@
+CREATE TABLE [dbo].[Payment]
+(
+[PaymentID] [int] NOT NULL IDENTITY(1, 1),
+[CheckNumber] [varchar] (50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[AmountPaid] [money] NOT NULL,
+[DateScanned] [date] NULL,
+[PrescriptionID] [int] NULL,
+[ClaimID] [int] NOT NULL,
+[CreatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPaymentCreatedOnUTC] DEFAULT (sysutcdatetime()),
+[UpdatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPaymentUpdatedOnUTC] DEFAULT (sysutcdatetime()),
+[DataVersion] [timestamp] NOT NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[Payment] ADD CONSTRAINT [pkPayment] PRIMARY KEY CLUSTERED  ([PaymentID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+ALTER TABLE [dbo].[Payment] ADD CONSTRAINT [fkPaymentClaimIDClaimClaimID] FOREIGN KEY ([ClaimID]) REFERENCES [dbo].[Claim] ([ClaimID])
+GO
+ALTER TABLE [dbo].[Payment] ADD CONSTRAINT [fkPaymentPrescriptionIDPrescriptionPrescriptionID] FOREIGN KEY ([PrescriptionID]) REFERENCES [dbo].[Prescription] ([PrescriptionID])
+GO
diff --git a/Tables/dbo.Payor.sql b/Tables/dbo.Payor.sql
new file mode 100644
index 0000000..3d4de63
--- /dev/null
+++ b/Tables/dbo.Payor.sql
@@ -0,0 +1,35 @@
+CREATE TABLE [dbo].[Payor]
+(
+[PayorID] [int] NOT NULL IDENTITY(1, 1),
+[GroupName] [varchar] (255) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[BillToName] [varchar] (255) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[BillToAddress1] [varchar] (255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[BillToAddress2] [varchar] (255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[BillToCity] [varchar] (155) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[BillToStateID] [int] NULL,
+[BillToPostalCode] [varchar] (100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[PhoneNumber] [varchar] (30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[AlternatePhoneNumber] [varchar] (30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[FaxNumber] [varchar] (30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[Notes] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[Contact] [varchar] (255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[ETLRowID] [varchar] (50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[CreatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPayorCreatedOnUTC] DEFAULT (sysutcdatetime()),
+[UpdatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPayorUpdatedOnUTC] DEFAULT (sysutcdatetime()),
+[DataVersion] [timestamp] NOT NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[Payor] ADD CONSTRAINT [pkPayor] PRIMARY KEY CLUSTERED  ([PayorID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxPayorBillToStateID] ON [dbo].[Payor] ([BillToStateID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+CREATE UNIQUE NONCLUSTERED INDEX [idxPayorGroupName] ON [dbo].[Payor] ([GroupName]) WITH (DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+CREATE UNIQUE NONCLUSTERED INDEX [idxUqPayorGroupName] ON [dbo].[Payor] ([GroupName]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+ALTER TABLE [dbo].[Payor] ADD CONSTRAINT [fkPayorBillToStateIDUsStateStateID] FOREIGN KEY ([BillToStateID]) REFERENCES [dbo].[UsState] ([StateID])
+GO
diff --git a/Tables/dbo.Pharmacy.sql b/Tables/dbo.Pharmacy.sql
new file mode 100644
index 0000000..b87bee8
--- /dev/null
+++ b/Tables/dbo.Pharmacy.sql
@@ -0,0 +1,34 @@
+CREATE TABLE [dbo].[Pharmacy]
+(
+[NABP] [varchar] (7) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[NPI] [varchar] (10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[PharmacyName] [varchar] (60) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[Address1] [varchar] (55) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[Address2] [varchar] (55) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[City] [varchar] (35) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[StateID] [int] NULL,
+[PostalCode] [varchar] (11) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[PhoneNumber] [varchar] (30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[AlternatePhoneNumber] [varchar] (30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[FaxNumber] [varchar] (30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[Contact] [varchar] (55) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[ContactPhoneNumber] [varchar] (30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[ContactEmailAddress] [varchar] (50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[FederalTIN] [varchar] (15) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[DispType] [char] (1) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[CreatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPharmacyCreatedOnUTC] DEFAULT (sysutcdatetime()),
+[UpdatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPharmacyUpdatedOnUTC] DEFAULT (sysutcdatetime()),
+[DataVersion] [timestamp] NOT NULL,
+[ETLRowID] [varchar] (50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[Pharmacy] ADD CONSTRAINT [pkPharmacy] PRIMARY KEY CLUSTERED  ([NABP]) WITH (FILLFACTOR=90, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxPharmacyStateID] ON [dbo].[Pharmacy] ([StateID]) ON [PRIMARY]
+GO
+ALTER TABLE [dbo].[Pharmacy] ADD CONSTRAINT [fkPharmacyStateIDUsStateStateID] FOREIGN KEY ([StateID]) REFERENCES [dbo].[UsState] ([StateID])
+GO
diff --git a/Tables/dbo.Prescription.sql b/Tables/dbo.Prescription.sql
new file mode 100644
index 0000000..cc4f577
--- /dev/null
+++ b/Tables/dbo.Prescription.sql
@@ -0,0 +1,60 @@
+CREATE TABLE [dbo].[Prescription]
+(
+[PrescriptionID] [int] NOT NULL IDENTITY(1, 1),
+[ClaimID] [int] NOT NULL,
+[RxNumber] [varchar] (100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[DateSubmitted] [datetime2] NOT NULL,
+[DateFilled] [datetime2] NOT NULL,
+[LabelName] [varchar] (25) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[NDC] [varchar] (11) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[Quantity] [float] NOT NULL,
+[DaySupply] [float] NOT NULL,
+[Generic] [char] (1) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[PharmacyNABP] [varchar] (7) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[AWPUnit] [float] NULL,
+[Usual] [decimal] (18, 0) NULL,
+[Prescriber] [varchar] (100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[PayableAmount] [money] NOT NULL,
+[BilledAmount] [money] NOT NULL,
+[TransactionType] [char] (1) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[Compound] [char] (1) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[TranID] [varchar] (14) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[RefillDate] [date] NULL,
+[RefillNumber] [smallint] NULL,
+[MONY] [char] (1) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[DAW] [smallint] NULL,
+[GPI] [varchar] (14) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[BillIngrCost] [float] NULL,
+[BillDispFee] [float] NULL,
+[BilledTax] [float] NULL,
+[BilledCopay] [float] NULL,
+[PayIngrCost] [float] NULL,
+[PayDispFee] [float] NULL,
+[PayTax] [float] NULL,
+[DEA] [varchar] (12) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[PrescriberNPI] [varchar] (12) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[Strength] [varchar] (255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[GPIGenName] [varchar] (255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[TheraClass] [varchar] (255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[InvoiceID] [int] NULL,
+[CreatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPrescriptionCreatedOnUTC] DEFAULT (sysutcdatetime()),
+[UpdatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPrescriptionUpdatedOnUTC] DEFAULT (sysutcdatetime()),
+[DataVersion] [timestamp] NOT NULL,
+[ETLRowID] [varchar] (50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[AWP] AS ([Quantity]*[AWPUnit])
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[Prescription] ADD CONSTRAINT [pkPrescription] PRIMARY KEY CLUSTERED  ([PrescriptionID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxPrescriptionClaimIDIncludes] ON [dbo].[Prescription] ([ClaimID]) INCLUDE ([LabelName], [PayableAmount], [RefillDate], [RxNumber]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxPrescriptionInvoiceIDIncludes] ON [dbo].[Prescription] ([InvoiceID]) INCLUDE ([ClaimID], [DateFilled], [LabelName], [RxNumber]) WHERE ([InvoiceID] IS NOT NULL) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+ALTER TABLE [dbo].[Prescription] ADD CONSTRAINT [fkPrescriptionClaimIDClaimClaimID] FOREIGN KEY ([ClaimID]) REFERENCES [dbo].[Claim] ([ClaimID])
+GO
+ALTER TABLE [dbo].[Prescription] ADD CONSTRAINT [fkPrescriptionInvoiceIDInvoiceInvoiceID] FOREIGN KEY ([InvoiceID]) REFERENCES [dbo].[Invoice] ([InvoiceID])
+GO
diff --git a/Tables/dbo.PrescriptionNote.sql b/Tables/dbo.PrescriptionNote.sql
new file mode 100644
index 0000000..1eb8850
--- /dev/null
+++ b/Tables/dbo.PrescriptionNote.sql
@@ -0,0 +1,23 @@
+CREATE TABLE [dbo].[PrescriptionNote]
+(
+[PrescriptionNoteID] [int] NOT NULL IDENTITY(1, 1),
+[PrescriptionNoteTypeID] [int] NOT NULL,
+[NoteText] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[EnteredByUserID] [nvarchar] (128) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[CreatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPrescriptionNoteCreatedOnUTC] DEFAULT (sysutcdatetime()),
+[UpdatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPrescriptionNoteUpdatedOnUTC] DEFAULT (sysutcdatetime()),
+[DataVersion] [timestamp] NOT NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[PrescriptionNote] ADD CONSTRAINT [pkPrescriptionNote] PRIMARY KEY CLUSTERED  ([PrescriptionNoteID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxPrescriptionNotePrescriptionNoteTypeIDEnteredByUserIDIncludeAll] ON [dbo].[PrescriptionNote] ([PrescriptionNoteTypeID], [EnteredByUserID]) INCLUDE ([CreatedOnUTC], [NoteText], [PrescriptionNoteID], [UpdatedOnUTC]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+ALTER TABLE [dbo].[PrescriptionNote] ADD CONSTRAINT [fkPrescriptionNoteEnteredByUserIDAspNetUsersID] FOREIGN KEY ([EnteredByUserID]) REFERENCES [dbo].[AspNetUsers] ([ID])
+GO
+ALTER TABLE [dbo].[PrescriptionNote] ADD CONSTRAINT [fkPrescriptionNotePrescriptionNoteTypeIDPrescriptionNoteTypePrescriptionNoteTypeID] FOREIGN KEY ([PrescriptionNoteTypeID]) REFERENCES [dbo].[PrescriptionNoteType] ([PrescriptionNoteTypeID])
+GO
diff --git a/Tables/dbo.PrescriptionNoteMapping.sql b/Tables/dbo.PrescriptionNoteMapping.sql
new file mode 100644
index 0000000..f2cb823
--- /dev/null
+++ b/Tables/dbo.PrescriptionNoteMapping.sql
@@ -0,0 +1,21 @@
+CREATE TABLE [dbo].[PrescriptionNoteMapping]
+(
+[PrescriptionID] [int] NOT NULL,
+[PrescriptionNoteID] [int] NOT NULL,
+[CreatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPrescriptionNoteMappingCreatedOnUTC] DEFAULT (sysutcdatetime()),
+[UpdatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPrescriptionNoteMappingUpdatedOnUTC] DEFAULT (sysutcdatetime()),
+[DataVersion] [timestamp] NOT NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[PrescriptionNoteMapping] ADD CONSTRAINT [pkPrescriptionNoteMapping] PRIMARY KEY CLUSTERED  ([PrescriptionID], [PrescriptionNoteID]) WITH (FILLFACTOR=95, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxPrescriptionNoteMappingIncludeAll] ON [dbo].[PrescriptionNoteMapping] ([PrescriptionID], [PrescriptionNoteID]) INCLUDE ([CreatedOnUTC], [UpdatedOnUTC]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
+ALTER TABLE [dbo].[PrescriptionNoteMapping] ADD CONSTRAINT [fkPrescriptionNoteMappingPrescriptionIDPrescriptionPrescriptionID] FOREIGN KEY ([PrescriptionID]) REFERENCES [dbo].[Prescription] ([PrescriptionID])
+GO
+ALTER TABLE [dbo].[PrescriptionNoteMapping] ADD CONSTRAINT [fkPrescriptionNoteMappingPrescriptionNoteIDPrescriptionNotePrescriptionNoteID] FOREIGN KEY ([PrescriptionNoteID]) REFERENCES [dbo].[PrescriptionNote] ([PrescriptionNoteID])
+GO
diff --git a/Tables/dbo.PrescriptionNoteType.sql b/Tables/dbo.PrescriptionNoteType.sql
new file mode 100644
index 0000000..78c8874
--- /dev/null
+++ b/Tables/dbo.PrescriptionNoteType.sql
@@ -0,0 +1,18 @@
+CREATE TABLE [dbo].[PrescriptionNoteType]
+(
+[PrescriptionNoteTypeID] [int] NOT NULL IDENTITY(1, 1),
+[TypeName] [varchar] (255) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[Code] [varchar] (10) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[CreatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPrescriptionNoteTypeCreatedOnUTC] DEFAULT (sysutcdatetime()),
+[UpdatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPrescriptionNoteTypeUpdatedOnUTC] DEFAULT (sysutcdatetime()),
+[DataVersion] [timestamp] NOT NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[PrescriptionNoteType] ADD CONSTRAINT [pkPrescriptionNoteType] PRIMARY KEY CLUSTERED  ([PrescriptionNoteTypeID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+CREATE UNIQUE NONCLUSTERED INDEX [idxUqPrescriptionNoteTypeCodeIncludeTypeName] ON [dbo].[PrescriptionNoteType] ([Code]) INCLUDE ([TypeName]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
diff --git a/Tables/dbo.PrescriptionPayment.sql b/Tables/dbo.PrescriptionPayment.sql
new file mode 100644
index 0000000..093511f
--- /dev/null
+++ b/Tables/dbo.PrescriptionPayment.sql
@@ -0,0 +1,20 @@
+CREATE TABLE [dbo].[PrescriptionPayment]
+(
+[PrescriptionPaymentID] [int] NOT NULL IDENTITY(1, 1),
+[CheckNumber] [varchar] (50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[AmountPaid] [money] NOT NULL,
+[DatePosted] [date] NULL,
+[PrescriptionID] [int] NOT NULL,
+[CreatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPrescriptionPaymentCreatedOnUTC] DEFAULT (sysutcdatetime()),
+[UpdatedOnUTC] [datetime2] NOT NULL CONSTRAINT [dfPrescriptionPaymentUpdatedOnUTC] DEFAULT (sysutcdatetime()),
+[DataVersion] [timestamp] NOT NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[PrescriptionPayment] ADD CONSTRAINT [pkPrescriptionPaymentID] PRIMARY KEY CLUSTERED  ([PrescriptionPaymentID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+ALTER TABLE [dbo].[PrescriptionPayment] ADD CONSTRAINT [FK__Prescript__Presc__26A5A303] FOREIGN KEY ([PrescriptionID]) REFERENCES [dbo].[Prescription] ([PrescriptionID])
+GO
diff --git a/Tables/dbo.UsState.sql b/Tables/dbo.UsState.sql
new file mode 100644
index 0000000..2feb958
--- /dev/null
+++ b/Tables/dbo.UsState.sql
@@ -0,0 +1,16 @@
+CREATE TABLE [dbo].[UsState]
+(
+[StateID] [int] NOT NULL IDENTITY(1, 1),
+[StateCode] [char] (2) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[StateName] [varchar] (64) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[IsTerritory] [bit] NOT NULL CONSTRAINT [dfUsStateIsTerritory] DEFAULT ((0))
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [dbo].[UsState] ADD CONSTRAINT [pkUsState] PRIMARY KEY CLUSTERED  ([StateID]) WITH (FILLFACTOR=90, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxUsStateStateNameStateCodeStateIDIncludeIsTerritory] ON [dbo].[UsState] ([StateName], [StateCode], [StateID]) INCLUDE ([IsTerritory]) WITH (FILLFACTOR=90, DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
diff --git a/Tables/etl.StagedLakerFile.sql b/Tables/etl.StagedLakerFile.sql
new file mode 100644
index 0000000..19b63aa
--- /dev/null
+++ b/Tables/etl.StagedLakerFile.sql
@@ -0,0 +1,172 @@
+CREATE TABLE [etl].[StagedLakerFile]
+(
+[RowID] [varchar] (50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
+[2] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[3] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[4] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[5] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[6] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[7] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[8] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[9] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[10] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[11] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[12] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[13] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[14] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[15] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[16] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[17] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[18] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[19] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[20] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[21] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[22] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[23] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[24] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[25] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[26] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[27] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[28] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[29] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[30] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[31] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[32] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[33] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[34] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[35] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[36] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[37] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[38] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[39] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[40] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[41] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[42] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[43] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[44] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[45] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[46] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[47] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[48] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[49] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[50] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[51] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[52] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[53] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[54] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[55] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[56] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[57] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[58] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[59] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[60] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[61] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[62] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[63] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[64] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[65] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[66] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[67] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[68] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[69] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[70] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[71] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[72] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[73] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[74] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[75] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[76] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[77] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[78] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[79] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[80] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[81] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[82] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[83] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[84] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[85] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[86] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[87] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[88] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[89] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[90] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[91] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[92] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[93] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[94] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[95] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[96] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[97] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[98] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[99] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[100] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[101] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[102] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[103] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[104] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[105] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[106] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[107] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[108] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[109] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[110] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[111] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[112] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[113] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[114] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[115] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[116] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[117] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[118] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[119] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[120] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[121] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[122] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[123] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[124] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[125] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[126] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[127] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[128] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[129] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[130] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[131] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[132] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[133] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[134] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[135] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[136] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[137] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[138] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[139] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[140] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[141] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[142] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[143] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[144] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[145] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[146] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[147] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[148] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[149] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[150] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[151] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[152] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[153] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[154] [varchar] (8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
+[AcctPayableID] [int] NULL,
+[PayorID] [int] NULL,
+[AdjustorID] [int] NULL,
+[PatientID] [int] NULL,
+[InvoiceID] [int] NULL,
+[ClaimID] [int] NULL,
+[PrescriptionID] [int] NULL,
+[PharmacyID] [int] NULL
+) ON [PRIMARY]
+WITH
+(
+DATA_COMPRESSION = ROW
+)
+GO
+ALTER TABLE [etl].[StagedLakerFile] ADD CONSTRAINT [pkStagedLakerFile] PRIMARY KEY CLUSTERED  ([RowID]) WITH (FILLFACTOR=100, DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
diff --git a/Views/dbo.vwClaim.sql b/Views/dbo.vwClaim.sql
new file mode 100644
index 0000000..11bdd70
--- /dev/null
+++ b/Views/dbo.vwClaim.sql
@@ -0,0 +1,37 @@
+SET QUOTED_IDENTIFIER ON
+GO
+SET ANSI_NULLS ON
+GO
+/*
+	Author:			Jordan Gurney
+	Create Date:	6/13/2017
+	Description:	View to reduce code footprint of query for Claims Panel
+	Sample Execute:
+					SELECT * FROM dbo.vwClaims
+*/
+CREATE VIEW [dbo].[vwClaim]
+AS 
+	SELECT DISTINCT ClaimId = c.ClaimID
+			, PayorId = pa.PayorID
+			, [Name] = NULLIF(ISNULL(LTRIM(RTRIM(p.FirstName)), '') + ' ' + ISNULL(LTRIM(RTRIM(p.LastName)), ''), ' ')
+			, c.ClaimNumber
+			, DateOfBirth = FORMAT(p.DateOfBirth, 'M/d/yyyy')
+			, InjuryDate = FORMAT(c.DateOfInjury, 'M/d/yyyy')
+			, Gender = g.GenderName
+			, Carrier = pa.BillToName
+			, Adjustor = a.AdjustorName
+			, AdjustorPhoneNumber = a.PhoneNumber
+			, DateEntered = FORMAT(c.TermDate, 'M/d/yyyy')
+			, AdjustorFaxNumber = a.FaxNumber
+			, i.InvoiceNumber
+			, p.FirstName
+			, p.LastName
+			, pre.RxNumber
+    FROM   dbo.Claim c 
+           LEFT JOIN dbo.Patient p INNER JOIN dbo.Gender g ON g.GenderID = p.GenderID ON p.PatientID = c.PatientID
+           LEFT JOIN dbo.Payor pa ON pa.PayorID = c.PayorID
+           LEFT JOIN dbo.Adjustor a ON a.AdjustorID = c.AdjusterID
+           LEFT JOIN dbo.Prescription pre ON pre.ClaimID = c.ClaimID
+		   LEFT JOIN dbo.Invoice i ON i.InvoiceID = pre.InvoiceID
+
+GO
diff --git a/Views/dbo.vwPrescriptionNote.sql b/Views/dbo.vwPrescriptionNote.sql
new file mode 100644
index 0000000..de49d65
--- /dev/null
+++ b/Views/dbo.vwPrescriptionNote.sql
@@ -0,0 +1,21 @@
+SET QUOTED_IDENTIFIER ON
+GO
+SET ANSI_NULLS ON
+GO
+CREATE VIEW [dbo].[vwPrescriptionNote]
+	WITH SCHEMABINDING
+	AS	
+		SELECT [p].[ClaimID], [p].[PrescriptionID], p.[RxNumber], p.[DateFilled], p.[LabelName],
+			[pn].[PrescriptionNoteID], [pnt].[TypeName] PrescriptionNoteType, [pn].[NoteText], 
+			[u].[FirstName] + ' '+ [u].[LastName] NoteAuthor,
+			[pn].[CreatedOnUTC] NoteCreatedOn, [pn].[UpdatedOnUTC] NoteUpdatedOn
+		FROM [dbo].[Prescription] AS [p]
+			INNER JOIN [dbo].[PrescriptionNoteMapping] AS [pnm] ON [pnm].[PrescriptionID] = [p].[PrescriptionID]
+			INNER JOIN [dbo].[PrescriptionNote] AS [pn] INNER JOIN [dbo].[PrescriptionNoteType] AS [pnt] ON [pnt].[PrescriptionNoteTypeID] = [pn].[PrescriptionNoteTypeID]
+				ON [pn].[PrescriptionNoteID] = [pnm].[PrescriptionNoteID]
+			INNER JOIN [dbo].[AspNetUsers] AS [u] ON [u].[ID] = [pn].[EnteredByUserID]
+GO
+CREATE UNIQUE CLUSTERED INDEX [idxUqClusVwPrescriptionNote] ON [dbo].[vwPrescriptionNote] ([PrescriptionID], [PrescriptionNoteID]) WITH (DATA_COMPRESSION = ROW) ON [PRIMARY]
+GO
+CREATE NONCLUSTERED INDEX [idxVwPrescriptionNoteClaimIDPrescriptionIDIncludeAll] ON [dbo].[vwPrescriptionNote] ([ClaimID], [PrescriptionID]) INCLUDE ([DateFilled], [LabelName], [NoteAuthor], [NoteCreatedOn], [NoteText], [NoteUpdatedOn], [PrescriptionNoteID], [PrescriptionNoteType], [RxNumber]) WITH (DATA_COMPRESSION = PAGE) ON [PRIMARY]
+GO
